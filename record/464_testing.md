464_What is "Testing"?

                                        <Code>                 "Code that tests your code"
            Manually test code -----------|-----------------| Automated code testing
Pro: Use app like your actual users              Pro: Cover all core features and run 
Con: Easy to forget a test or test too little    automatically after every code change
                                                 Con: Only tests what you define, hard to test UI

여태까지는 코드를 작성하고 페이지에 들어가거나 API에 요청을 보내는 식으로 직접 테스트했다. 가장 큰 이점은 페이지를 직접 볼 수 있다는 점이다. 사용자가 보게 되는 페이지를 미리 확인할 수 있고 개발자로서 원하는 대로 API와 상호 작용할 수 있기 때문에 매뉴얼 테스트는 아주 중요하다. 
하지만 단점도 있다. 테스트 자체를 잊어버리거나 일부분만 테스트할 수 있다. 특히 코드를 변경할 때 의도치 않게 앱의 일부분을 중단하고도 의식하지 못해서 따로 테스트하지 않을 수도 있다. 시간이 지나서 혹은 아예 오류를 잡지 못하면 문제가 될 것이다. 또한 앱의 모든 기능을 테스트하거나 코드를 변경할 때마다 테스트하기 어려우므로 테스트 자동화가 필요하다.
테스트 자동화는 코드를 테스트하는 코드를 작성하는 것이다. 실행되는 과정을 정의하고 테스트할 시나리오들을 정의해 중요한 변경 사항이 생길 때마다 자동으로 테스트를 실행하도록 설정해 원하는 대로 실행할 수 있다. 배포 과정에도 포함해서 앱이 배포되기 전에 테스트를 실행해 테스트 중 일부라도 실패하면 오류를 나타내게 할 수도 있다. 그럼 테스트를 살펴보며 오류를 찾고 고칠 수 있다.
테스트 자동화의 가장 큰 이점은 모든 핵심 기능을 살펴보고 테스트를 진행할 모든 시나리오를 정의해서 변경 사항을 만들었을 때 앱이 중지되지 않도록 한다는 것이다.
당연히 단점도 있다. 테스트하는 코드에 시나리오를 잘못 입력해서 모든 테스트에 문제가 일어나지 않는 것이다. 또한 정의해둔 부분만 테스트할 수 있고 사용자가 보는 화면을 볼 수 없어서 UI를 테스트하기 어렵다.
===========================================================================================
465_Why "Testing"?

테스트 자동화는 모든 코드를 자동으로 테스트하도록 한다. '모든' 뒤에 별표가 붙은 이유는 정의한 것에 한해 모든 코드를 테스트하기 때문이다. 작성한 테스트만 진행한다. 하지만 이론상으로는 코드가 수정될 때마다 앱의 모든 부분을 테스트할 수 있기 때문에 코드 수정 후 예상치 못한 곳에서 문제가 생기더라도 어디서 코드가 잘못됐는지 쉽게 감지한다. 특히 테스트 자동화를 통해 테스트 과정이 예상 가능하도록 분명하게 정의할 수 있다. 
이렇게 코드에 과정을 정의해두기 때문에 테스트가 항상 같은 방식으로 실행된다. 다시 말해, 항상 시나리오가 같다는 가정 아래 테스트를 진행하는 것이다. 앱을 직접 테스트하는 경우에는 지난번과 같은 과정을 반복한다고 해도 실수로 한 단계를 건너뛰는 등 완전히 동일하지 않을 수도 있다. 그래서 테스트가 필요하다.

Testing Tools & Setup

Node.js를 이용해 서버에서 뷰를 렌더링하는 페이지든, REST API, GraphQL API를 구축하든지 간에 테스트가 자동으로 실행되도록 만들어야 한다. 완성한 코드를 테스트하는 코드를 실행하기 위해서는 몇 가지 툴이 필요하다.
우선 테스트 코드를 실행하는 툴이 필요하다. 코드를 실행할 뿐만 아니라 테스트를 통과했는지 실패했는지 결과를 알려주는 툴이다. 테스트 실행에 필요한 프레임워크로는 Mocha가 유명하다. 
두 번째 툴은 코드 실행에서 나아가 충족해야 하는 일정 조건을 정의해서 특정 결과만 나오도록 한다. 특정 시나리오, 즉 테스트가 성공했는지 알려면 어떤 경우에 성공이라고 간주하는지 테스트에 정의해서 테스트 결과를 검사해야 하는데 테스트의 모든 과정에는 여러 툴이 필요하다. 이때는 Chai가 유명하다. Jest라는 대안도 있다. 
Side Effects(부작용)을 관리하고 외부 의존성이나 복잡한 시나리오를 다룰 때는 Sinon이라는 툴을 이용해 stub 및 mock를 생성한다. 
===========================================================================================
466_테스트 설정 및 작성

원활한 테스트 자동화 학습을 위해서 async/await로 REST API를 막 끝낸 시점의 프로젝트로 돌아간다. 
테스트를 위한 패키지를 설치한다.
    npm install --save-dev mocha chai

우선 package.json의 scripts 섹션에서 "test" 스크립트가 있을 것이다. 없으면 추가한다. 디폴트 값은 쓸모없으니 지우고 mocha 를 입력한다.
package.json => scripts
    "test": "mocha --timeout 5000"
- 옵션으로 --timeout을 작성하고 숫자를 입력하면 타임아웃에 필요한 시간을 조절할 수 있다. 단위는 ms이다. 디폴트는 2000이다. 추후 DB에 접근하려면 5000 정도로 설정한다.

이제 Terminal에 npm test를 입력하면 프로젝트에 정의된 모든 테스트가 실행된다. 당연히 지금은 아무 테스트도 없다. Mocha는 디폴트로 'test'라는 폴더를 찾는다. 그러므로 루트 디렉토리에 test 폴더를 생성한다. tests 등의 다른 이름은 안 된다. 여기에 테스트 코드를 가질 파일을 정의한다.
파일 이름은 상관없지만 .js 파일이어야 한다. start.js 파일을 생성해본다.
start.js =>
    const expect = require('chai').expect;

    it('should add numbers correctly', function() {
        const num1 = 2;
        const num2 = 3;
        expect(num1 + num2).to.equal(5);
    })
    it('should not give a result of 6', function() {
        const num1 = 3;
        const num2 = 3;
        expect(num1 + num2).not.to.equal(6);
    })
- 테스트 코드는 it으로 시작한다. Mocha가 제공하는 기능이다. 함수 이름이 이상해 보이지만 테스트에 이름을 붙이면 평범한 영어 문장으로 읽히도록 두 개의 인수를 가진다. 
- 첫 번째는 테스트를 설명하는 문자열이다. 테스트 결과에 나오므로 테스트 성공 여부를 구별하는 데 도움을 준다. 함수 이름과 합치면 마치 영어 문장처럼 읽힌다.(It should add numbers correctly) 이론상으로 아무 텍스트나 상관없지만 이런 식으로 문장을 쓰는게 보편적이다. 
- 두 번째 인수가 중요하다. 테스트 코드를 정의하는 function()을 넣는다. 모델이나 컨트롤러에 도달해 테스트하도록 말이다.
- 성공 조건을 정의한다. 이를 위해 Chai가 필요하다. Mocha는 테스트를 실행하고 테스트 코드를 정의하는 it 함수를 제공한다면 Chai는 성공 조건을 정의하는 역할을 한다. should라는 카워드로 조건을 다르게 정의할 수도 있지만 여기선 expect를 사용한다. 테스트 조건을 작성하는 방법에만 차이가 있다. expect를 함수로 호출하고 테스트하고자 하는 코드나 결과를 인수로 전달한다. 이 경우에는 num1 + num2 이다. 
- 예상 결괏값을 정의한다. 영어 문장을 작성하는 것과 비슷한데 Chai가 반환할 객체에 몇 가지 속성을 준다. to 같은 속성이 그것이다. to에는 또 다른 객체로 equal 함수를 사용할 수 있으며 equal()에 테스트 결괏값을 정의한다. 위의 예제에서는 num1 + num2가 5가 나오기를 기대하고 있다.

다시 npm start를 실행하면 test 폴더를 찾아 모든 테스트와 파일을 실행하고 터미널에 결과가 출력된다.
===========================================================================================
467_auth middleware test

위에서는 테스트 패키지 사용법을 알아보았다. 단순히 자바스크립트 코드를 실행한 것에 불과하므로 의미는 없다. 내가 작성한 코드를 테스트해보자. auth-middleware.js 파일을 생성하고 is-auth.js 파일을 임포트한다.
auth-middleware.js =>
    const authMiddleware = require('../middleware/is-auth');

첫 번째 테스트는 권한 헤더가 없을 때 실제로 오류가 발생하는 지 확인하는 것이다.
    it('should throw an error if no authorization header is present', function() {
        const req = {
            get: function(headerName) {
                return null;
            }
        };
        expect(authMiddleware.bind(this, req, {}, () => {})).to.throw('Not authenticated.');
    });
- function의 안에 off middleware manual을 호출하면 좋은데 왜냐하면 전체 요청 플로우를 시뮬레이션하는 게 아니기 때문이다. 사용자가 클릭하여 요청을 전송하고 미들웨어를 트리거하는 동작을 시뮬레이션할 게 아니다. 
- 더미 req을 작성하는 이유는 해당 객체가 res, next 처럼 express 미들웨어에서 일반적으로 전달되기 때문이다.
- 여기선 직접 요청 객체를 정의했는데 다양한 시나리오를 정의할 수 있어서 유용하다. 
- get: function을 is-auth 미들웨어에서 호출하므로(const authHeader = req.get('Authorization')) 객체가 get: function을 가져야 하며 실제로는 이 get: function이 권한 헤더의 값을 반환한다. 물론 express가 제공하는 get 메서드는 훨씬 복잡하다. 헤더의 스캔뿐만 아니라 들어오는 요청의 다양한 부분도 스캔한다. 여기서의 목표는 get 메서드가 권한 헤더를 반환하지 않는 시나리오를 작성하는 것이다. 즉 이 함수는 단순히 null을 반환한다.
- auth 미들웨어에선 get 메서드에 대한 'Authorization' 문자열을 전달하고 있는데 이를 위해 인수를 추가할 수는 있다.(headerName) 물론 지금 필요는 없다. 
- 이후 auth 미들웨어를 호출해서 다른 요소가 빠진 request 객체를 전달할 수 있다. res는 빈 객체를 전달하는데 이 응답 객체에 관련된 걸 전혀 테스트하지 않기 때문이다. next도 다음 단계를 테스트하지 않으니 빈 화살표 함수만 전달한다.
- throw는 메시지와 함께 오류를 출력할 것을 예상한다.
- 미들웨어를 직접 호출하면 에러가 발생한다. 인증 미들웨어에서 직접 에러를 출력하는 것이다. 테스트하는 프레임워크에서 호출하게 해야한다. 즉, mocha, chai에 미들웨어의 참조만을 expect 함수에 전달한다. 그리고 테스트 설정이 함수를 호출할 때 전달하려는 인수를 bind한다. 이때 bind는 this 키워드에 대한 입력값을 요구한다. 이제 준비된 참조를 expect로 전달하게 된다.

이와같은 테스트 방식은 미들웨어 함수만을 테스트하는 것인데 이것을 Unit test(유닛 테스트) 라고 한다. 일반적으로 유닛은 함수다. Integration test(통합 테스트)은 좀 더 완성된 플로우를 테스트한다. 요청이 올바르게 라우트되는지, 모든 미들웨어와 컨트롤러 함수까지 테스트할 수 있다. 그러나 그 정도로 긴 체인을 테스트하는 것은 복잡하기 때문에 자주 진행하지 않는다. 따라서 실패할 만한 변수들이 다수 존재한다. 반면 유닛 테스트는 모두 성공했다면 앱의 실행을 어느정도 보장해주기 때문에 매우 유용하다. 또한 실패하더라도 알아내기가 쉽다.
===========================================================================================
468_여러 테스트 구성

테스트를 더 추가해본다.
    it('should throw an error if the authorization header is only one string', function() {
        const req = {
            get: function() {
                return 'xyz';
            }
        };
        expect(authMiddleware.bind(this, req, {}, () => {})).to.throw();
    });
- 토큰 값으로 'xyz'를 갖도록 한다. 
- 이전의 예시처럼 정확한 오류 메시지를 확인할 수 있으나 확실하지 않거나 오류의 출력 여부에만 관심이 있다면 인수를 전달하지 않고 throw만 확인할 수 있다.

테스트하면 성공한다. 즉, 'xyz' 토큰을 전달하면 실패했다는 뜻이다.

더 많은 테스트를 추가할수록 출력값을 읽기 어려워진다. 이를 위해 Mocha에서 테스트 정의 및 조직함에 있어 it 함수 이상을 제공한다. describe 함수로 테스트를 묶어서 원하는 만큼 describe 함수 호출을 중첩할 수 있다. 즉, 각자의 내부에 describe 함수가 여러개 존재할 수 있다. 
describe 함수는 제목을 가질 수 있는데 영어 문장처럼 읽히는 문장이 아니라 설명하는 그룹에 대한 헤더, 예를 들어 Auth Middleware 등이 있다.
describe는 두 번째 인수로 함수를 가지며 함수 내부로 it 함수 호출이 이루어질 때마다 모든 테스트 Case(사례)를 전달한다. 즉, 이제 위의 테스트 케이스들은 describe 함수 내부에 존재한다.
    describe('Auth Middleware', function() {
        it('...', function() {
            ...
        }
        
        it('...', function() {
            ...
        }

        describe('...', function() {
            ...
        });
    });

테스트해보면 헤더가 생성되어 테스트들이 소속된 파일이나 앱의 코드 영역을 확인하기 더 쉬워졌다.
===========================================================================================
469_테스트하지 말아야 할 것!

토큰은 어떻게 테스트할까? 정확하지 않은 토큰에 대해 실패를 유도하는 방법은 무엇일까? 
몇 가지 중요한 요소들이 있는데 verify 함수가 올바르게 작동하는지 테스트해서는 안 된다. 즉, 실제로 토큰을 올바르게 확인하는지 테스트하면 안 된다. 왜냐하면 우리가 보유한 함수나 메서드가 아니기 때문이다. 이 앱에서는 제3자 패키지인 jsonwebtoken을 사용하므로 코드를 테스트하여 작동을 보장하는 것은 패키지 제공자 측에서 할 일이다. 외부 디펜던시를 테스트할 필요가 없다. 따라서 토큰 확인에 실패하거나 성공했을 때 우리의 코드가 올바르게 작동하는지 만을 테스트한다.
만약 코드가 잘 작동하는지를 테스트하려면 실패를 테스트하는 쪽이 쉽다. 이 패키지에서 확인되지 않은 토큰을 쉽게 전달할 수 있는데 어떤 토큰이 우리에게 생성되는지를 모르기 때문이다. 토큰은 굉장히 긴 문자열이라서 추측할 수 없다. 즉, 우리가 함수에 전달하는 내용은 이 verify 단계에서 아마 실패할 것이다. 

auth-middleware.js =>
    it('should throw an error if the token cannot be verified', function() {
        const req = {
            get: function() {
                return 'Bearer xyz';
            }
        };
        expect(authMiddleware.bind(this, req, {}, () => {})).to.throw();
    });

verify 함수에서 오류가 출력될 것이므로 이 테스트는 반드시 성공한다. 반대로 유효한 토큰인지를 테스트할 경우 다른 테스트를 작성할 수 있다. 이때 토큰을 decode(해독)하여 우리에게 반환되는 객체에 userId가 있어야 한다.
    it('should yield a userId after decoding the token', function() {
        const req = {
            get: function() {
                return 'Bearer sadadaqwedkndekslfhadwqkjdhasidak';
            }
        };
        expect(authMiddleware.bind(this, req, {}, () => {})).to.throw();
    });

req에 userId가 추가되도록 인증 미들웨어를 수동으로 호출하여 요청과 응답 객체 그리고 빈 next 함수를 전달한다. 

    it('should yield a userId after decoding the token', function() {
        ...
        authMiddleware(req, {}, () => {});
        expect(req).to.have.property('userId');
    });
- 이 미들웨어를 실행하면 요청 객체에서 새 속성을 예측하는데 새로운 속성인 userId 속성을 추가했기 때문이다. req.userId가 특정 값과 동일한지 비교하거나 이름이 'userId'인 to.have.property를 입력해도 된다. userId는 토큰이 유효한 경우 예측할 수 있는 부분이다. 

테스트를 실행하면 실패한다. 토큰이 지나치게 짧아 jwt의 verify 메서드의 기준을 충족하지 않아 오류가 출력된다.
실패하는 경우를 늘 테스트할 수는 없으나 성공하는 케이스는 테스트할 텐데 왜냐하면 오류로 인해 실패하지 않으나 단순히 해당 코드가 존재하지 않기 때문에 userId가 요청에 저장되지 않는 시나리오가 앱에 존재할 수 있기 때문이다. 해당 userId는 이후 컨트롤러에서 가져오려고 시도하겠지만 컨트롤러에서는 에러를 출력하지 않는다. 따라서 이런 테스트가 매우 중요해진다. 왜냐하면 여기에서 미들웨어를 실행한 뒤 userId가 req 객체에 저장되었는지를 테스트하기 때문이다. 

이러한 에러를 발견하려면 verify 메서드를 끄는 방법이 필요하다. 입력한 토큰이 유효하지 않다는 사실은 이미 알고 있다. 그러나 이 테스트에서는 관계없다. 토큰의 유효성과는 상관없이 유효한 토큰에 대해 우리의 앱이 올바르게 작동하는가를 테스트하는 것이 목적이다.
===========================================================================================
470_Stubs 사용

이러한 문제를 해결하려면 stubs나 mocks를 사용하는데 검증 메서드를 보다 단순한 메서드로 교체하는 것이다. 
테스트 파일에 jwt 패키지를 임포트하고 jwt.verify를 호출한 뒤 새로운 함수와 동일하게 설정해준다.
    it('should yield a userId after decoding the token', function() {
        ...
        jwt.verify = function() {
            return { userId: 'abc }
        }
        authMiddleware(req, {}, () => {});
        expect(req).to.have.property('userId');
    });
- 실제로 jwt 패키지에 있는 verify 메서드를 덮어쓰는 구문이다. 이렇게 덮어쓸 때 모듈 임포트가 node.js에서 작동하는 방식은 한 개의 전역 패키지가 있으므로 가능하다. 즉 커스텀 함수로 변경되며 테스트를 실행하면 변경한 함수로 실행된다. 

테스트를 실행하면 의도한대로 테스트를 진행할 수 있게 되었다. 그러나 수동으로 덮어쓰면 큰 단점이 존재한다. 방금 작성한 테스트 코드를 그 전에 진행한 테스트 앞으로 옮기면 에러가 발생한다. 원래 있던 테스트도 토큰과 관계가 있는데 verify 메서드를 덮어씀으로써 오류가 절대로 발생하지 않게 되어버렸다. 즉, 다른 테스트에서 원본 verify 메서드를 필요로 했다면 새로 작성한 테스트에서 커스텀 함수로 교체해 버렸기 때문에 더 이상 사용할 수 없다. 

따라서 기능을 수동으로 스터빙 내지는 모킹하여 교체하는 것보다는 원본 설정을 복원해 주는 패키지를 사용하는 것이 좋다. 
    npm install --save-dev sinon
Sinon은 stub이라고 하는 원본 함수의 대체품을 생성하는 패키지인데 원본 함수를 쉽게 복원할 수 있다. 
    const sinon = require('sinon');
    ...
    sinon.stub(jwt, 'verify');
- sinon.stub을 호출하고 첫 번째 인수로 교체하려는 메서드가 있는 객체를 전달한다. 이 경우 jwt이다. 두 번째로 변경할 메서드 이름을 문자열로 전달한다.
- 이제 sinon은 디폴트로 공백 함수로 교체하고 특별한 기능을 수행하지 않는데 꼭 그것만은 아니다. 함수 호출을 등록하는 등의 기능이 있어 실행되는 요소의 종류와 관계없이 이 함수가 호출될지의 여부 등을 테스트할 수도 있다.
    jwt.verify.returns({userId: 'abc'});
- stub된 메서드에 접근하여 returns를 호출한다. verify 메서드는 sinon이 추가되어 실행될 수는 없으나 구성될 수 있는 객체를 최종적으로 확인한다. 또한 returns는 이 함수가 무엇을 반환할지 구성할 수 있게 해준다.
- jwt.verify를 호출할 때마다 실제로는 이 stub을 호출하는 것이다.
    authMiddleware(req, {}, () => {});
    expect(req).to.have.property('userId');
    expect(req).to.have.property('userId', 'abc');
- 높은 완성도를 위해서 요청에 특정 값을 지닌 userId 속성이 존재하는지 테스트할 수 있다. 위에서 abc 값을 정의했으므로 일종의 중복 테스트에 해당한다. 
    expect(jwt.verify.called).to.be.true;
- verify 메서드가 호출되었는지 확인할 수 있다.
    jwt.verify.restore();
- 원본 함수를 복원한다. 기존 메서드를 스텁으로 교체했으면 반드시 복원해야 한다.

이렇게 외부 메서드를 교체하면서도 작업이 끝나고 모든 것을 복원하여 원본 기능이 필요한 다른 테스트도 잘 작동하는 방법을 배웠다.
===========================================================================================