464_What is "Testing"?

                                        <Code>                 "Code that tests your code"
            Manually test code -----------|-----------------| Automated code testing
Pro: Use app like your actual users              Pro: Cover all core features and run 
Con: Easy to forget a test or test too little    automatically after every code change
                                                 Con: Only tests what you define, hard to test UI

여태까지는 코드를 작성하고 페이지에 들어가거나 API에 요청을 보내는 식으로 직접 테스트했다. 가장 큰 이점은 페이지를 직접 볼 수 있다는 점이다. 사용자가 보게 되는 페이지를 미리 확인할 수 있고 개발자로서 원하는 대로 API와 상호 작용할 수 있기 때문에 매뉴얼 테스트는 아주 중요하다. 
하지만 단점도 있다. 테스트 자체를 잊어버리거나 일부분만 테스트할 수 있다. 특히 코드를 변경할 때 의도치 않게 앱의 일부분을 중단하고도 의식하지 못해서 따로 테스트하지 않을 수도 있다. 시간이 지나서 혹은 아예 오류를 잡지 못하면 문제가 될 것이다. 또한 앱의 모든 기능을 테스트하거나 코드를 변경할 때마다 테스트하기 어려우므로 테스트 자동화가 필요하다.
테스트 자동화는 코드를 테스트하는 코드를 작성하는 것이다. 실행되는 과정을 정의하고 테스트할 시나리오들을 정의해 중요한 변경 사항이 생길 때마다 자동으로 테스트를 실행하도록 설정해 원하는 대로 실행할 수 있다. 배포 과정에도 포함해서 앱이 배포되기 전에 테스트를 실행해 테스트 중 일부라도 실패하면 오류를 나타내게 할 수도 있다. 그럼 테스트를 살펴보며 오류를 찾고 고칠 수 있다.
테스트 자동화의 가장 큰 이점은 모든 핵심 기능을 살펴보고 테스트를 진행할 모든 시나리오를 정의해서 변경 사항을 만들었을 때 앱이 중지되지 않도록 한다는 것이다.
당연히 단점도 있다. 테스트하는 코드에 시나리오를 잘못 입력해서 모든 테스트에 문제가 일어나지 않는 것이다. 또한 정의해둔 부분만 테스트할 수 있고 사용자가 보는 화면을 볼 수 없어서 UI를 테스트하기 어렵다.
===========================================================================================
465_Why "Testing"?

테스트 자동화는 모든 코드를 자동으로 테스트하도록 한다. '모든' 뒤에 별표가 붙은 이유는 정의한 것에 한해 모든 코드를 테스트하기 때문이다. 작성한 테스트만 진행한다. 하지만 이론상으로는 코드가 수정될 때마다 앱의 모든 부분을 테스트할 수 있기 때문에 코드 수정 후 예상치 못한 곳에서 문제가 생기더라도 어디서 코드가 잘못됐는지 쉽게 감지한다. 특히 테스트 자동화를 통해 테스트 과정이 예상 가능하도록 분명하게 정의할 수 있다. 
이렇게 코드에 과정을 정의해두기 때문에 테스트가 항상 같은 방식으로 실행된다. 다시 말해, 항상 시나리오가 같다는 가정 아래 테스트를 진행하는 것이다. 앱을 직접 테스트하는 경우에는 지난번과 같은 과정을 반복한다고 해도 실수로 한 단계를 건너뛰는 등 완전히 동일하지 않을 수도 있다. 그래서 테스트가 필요하다.

Testing Tools & Setup

Node.js를 이용해 서버에서 뷰를 렌더링하는 페이지든, REST API, GraphQL API를 구축하든지 간에 테스트가 자동으로 실행되도록 만들어야 한다. 완성한 코드를 테스트하는 코드를 실행하기 위해서는 몇 가지 툴이 필요하다.
우선 테스트 코드를 실행하는 툴이 필요하다. 코드를 실행할 뿐만 아니라 테스트를 통과했는지 실패했는지 결과를 알려주는 툴이다. 테스트 실행에 필요한 프레임워크로는 Mocha가 유명하다. 
두 번째 툴은 코드 실행에서 나아가 충족해야 하는 일정 조건을 정의해서 특정 결과만 나오도록 한다. 특정 시나리오, 즉 테스트가 성공했는지 알려면 어떤 경우에 성공이라고 간주하는지 테스트에 정의해서 테스트 결과를 검사해야 하는데 테스트의 모든 과정에는 여러 툴이 필요하다. 이때는 Chai가 유명하다. Jest라는 대안도 있다. 
Side Effects(부작용)을 관리하고 외부 의존성이나 복잡한 시나리오를 다룰 때는 Sinon이라는 툴을 이용해 stub 및 mock를 생성한다. 
===========================================================================================
466_테스트 설정 및 작성

원활한 테스트 자동화 학습을 위해서 async/await로 REST API를 막 끝낸 시점의 프로젝트로 돌아간다. 
테스트를 위한 패키지를 설치한다.
    npm install --save-dev mocha chai

우선 package.json의 scripts 섹션에서 "test" 스크립트가 있을 것이다. 없으면 추가한다. 디폴트 값은 쓸모없으니 지우고 mocha 를 입력한다.
package.json => scripts
    "test": "mocha --timeout 5000"
- 옵션으로 --timeout을 작성하고 숫자를 입력하면 타임아웃에 필요한 시간을 조절할 수 있다. 단위는 ms이다. 디폴트는 2000이다. 추후 DB에 접근하려면 5000 정도로 설정한다.

이제 Terminal에 npm test를 입력하면 프로젝트에 정의된 모든 테스트가 실행된다. 당연히 지금은 아무 테스트도 없다. Mocha는 디폴트로 'test'라는 폴더를 찾는다. 그러므로 루트 디렉토리에 test 폴더를 생성한다. tests 등의 다른 이름은 안 된다. 여기에 테스트 코드를 가질 파일을 정의한다.
파일 이름은 상관없지만 .js 파일이어야 한다. start.js 파일을 생성해본다.
start.js =>
    const expect = require('chai').expect;

    it('should add numbers correctly', function() {
        const num1 = 2;
        const num2 = 3;
        expect(num1 + num2).to.equal(5);
    })
    it('should not give a result of 6', function() {
        const num1 = 3;
        const num2 = 3;
        expect(num1 + num2).not.to.equal(6);
    })
- 테스트 코드는 it으로 시작한다. Mocha가 제공하는 기능이다. 함수 이름이 이상해 보이지만 테스트에 이름을 붙이면 평범한 영어 문장으로 읽히도록 두 개의 인수를 가진다. 
- 첫 번째는 테스트를 설명하는 문자열이다. 테스트 결과에 나오므로 테스트 성공 여부를 구별하는 데 도움을 준다. 함수 이름과 합치면 마치 영어 문장처럼 읽힌다.(It should add numbers correctly) 이론상으로 아무 텍스트나 상관없지만 이런 식으로 문장을 쓰는게 보편적이다. 
- 두 번째 인수가 중요하다. 테스트 코드를 정의하는 function()을 넣는다. 모델이나 컨트롤러에 도달해 테스트하도록 말이다.
- 성공 조건을 정의한다. 이를 위해 Chai가 필요하다. Mocha는 테스트를 실행하고 테스트 코드를 정의하는 it 함수를 제공한다면 Chai는 성공 조건을 정의하는 역할을 한다. should라는 카워드로 조건을 다르게 정의할 수도 있지만 여기선 expect를 사용한다. 테스트 조건을 작성하는 방법에만 차이가 있다. expect를 함수로 호출하고 테스트하고자 하는 코드나 결과를 인수로 전달한다. 이 경우에는 num1 + num2 이다. 
- 예상 결괏값을 정의한다. 영어 문장을 작성하는 것과 비슷한데 Chai가 반환할 객체에 몇 가지 속성을 준다. to 같은 속성이 그것이다. to에는 또 다른 객체로 equal 함수를 사용할 수 있으며 equal()에 테스트 결괏값을 정의한다. 위의 예제에서는 num1 + num2가 5가 나오기를 기대하고 있다.

다시 npm start를 실행하면 test 폴더를 찾아 모든 테스트와 파일을 실행하고 터미널에 결과가 출력된다.
===========================================================================================
467_auth middleware test

위에서는 테스트 패키지 사용법을 알아보았다. 단순히 자바스크립트 코드를 실행한 것에 불과하므로 의미는 없다. 내가 작성한 코드를 테스트해보자. auth-middleware.js 파일을 생성하고 is-auth.js 파일을 임포트한다.
auth-middleware.js =>
    const authMiddleware = require('../middleware/is-auth');

첫 번째 테스트는 권한 헤더가 없을 때 실제로 오류가 발생하는 지 확인하는 것이다.
    it('should throw an error if no authorization header is present', function() {
        const req = {
            get: function(headerName) {
                return null;
            }
        };
        expect(authMiddleware.bind(this, req, {}, () => {})).to.throw('Not authenticated.');
    });
- function의 안에 off middleware manual을 호출하면 좋은데 왜냐하면 전체 요청 플로우를 시뮬레이션하는 게 아니기 때문이다. 사용자가 클릭하여 요청을 전송하고 미들웨어를 트리거하는 동작을 시뮬레이션할 게 아니다. 
- 더미 req을 작성하는 이유는 해당 객체가 res, next 처럼 express 미들웨어에서 일반적으로 전달되기 때문이다.
- 여기선 직접 요청 객체를 정의했는데 다양한 시나리오를 정의할 수 있어서 유용하다. 
- get: function을 is-auth 미들웨어에서 호출하므로(const authHeader = req.get('Authorization')) 객체가 get: function을 가져야 하며 실제로는 이 get: function이 권한 헤더의 값을 반환한다. 물론 express가 제공하는 get 메서드는 훨씬 복잡하다. 헤더의 스캔뿐만 아니라 들어오는 요청의 다양한 부분도 스캔한다. 여기서의 목표는 get 메서드가 권한 헤더를 반환하지 않는 시나리오를 작성하는 것이다. 즉 이 함수는 단순히 null을 반환한다.
- auth 미들웨어에선 get 메서드에 대한 'Authorization' 문자열을 전달하고 있는데 이를 위해 인수를 추가할 수는 있다.(headerName) 물론 지금 필요는 없다. 
- 이후 auth 미들웨어를 호출해서 다른 요소가 빠진 request 객체를 전달할 수 있다. res는 빈 객체를 전달하는데 이 응답 객체에 관련된 걸 전혀 테스트하지 않기 때문이다. next도 다음 단계를 테스트하지 않으니 빈 화살표 함수만 전달한다.
- throw는 메시지와 함께 오류를 출력할 것을 예상한다.
- 미들웨어를 직접 호출하면 에러가 발생한다. 인증 미들웨어에서 직접 에러를 출력하는 것이다. 테스트하는 프레임워크에서 호출하게 해야한다. 즉, mocha, chai에 미들웨어의 참조만을 expect 함수에 전달한다. 그리고 테스트 설정이 함수를 호출할 때 전달하려는 인수를 bind한다. 이때 bind는 this 키워드에 대한 입력값을 요구한다. 이제 준비된 참조를 expect로 전달하게 된다.

이와같은 테스트 방식은 미들웨어 함수만을 테스트하는 것인데 이것을 Unit test(유닛 테스트) 라고 한다. 일반적으로 유닛은 함수다. Integration test(통합 테스트)은 좀 더 완성된 플로우를 테스트한다. 요청이 올바르게 라우트되는지, 모든 미들웨어와 컨트롤러 함수까지 테스트할 수 있다. 그러나 그 정도로 긴 체인을 테스트하는 것은 복잡하기 때문에 자주 진행하지 않는다. 따라서 실패할 만한 변수들이 다수 존재한다. 유닛 테스트가 모두 성공했다면 앱의 실행을 어느정도 보장해주기 때문에 매우 유용하다. 또한 실패하더라도 알아내기가 쉽다.