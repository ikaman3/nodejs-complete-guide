481_npm & Node.js

Beyond Node Web Servers

Node와 더불어 Node.js 설치 시 무료로 받는 npm을 구축 툴로 사용할 수 있다. 컴퓨터에 유틸리티 스크립트를 실행하는 툴로 대부분 자바스크립트 기반 프로젝트 구축을 돕는다. 웹 앱이거나 특히 서버 측 웹 앱일 필요는 없고 프론트엔드 웹 앱이어도 된다.

Two for the Price of One

Node.js: Execute Code, Interact with Files

npm: Manage Packages, Run Scripts

Node.js를 설치하면 두 개의 도구를 이용할 수 있다. Node.js, npm이다. 프로젝트에 패키지를 설치하거나 코드 첨부파일과 함께 프로젝트를 공유할 때 사용한 도구이다. 코드 첨부파일은 Node 모듈 폴더를 공유하지 않아도 외부 디펜던시를 다시 설치할 수 있도록 package.json 파일이 모든 디펜던시를 가진다. 
즉, Node.js는 Node.js의 런타임과 기능에 기반해 자바스크립트 코드를 실행하기 위한 프로그래밍 언어로, 빌드 도구에 측면에서 봤을 때 Node.js를 이용하면 파일과 상호 작용할 수 있다는 점이 중요한 사실이 된다.
npm은 노드 패키지 매니저로, 패키지를 관리하는 데 사용되어 패키지를 설치, 다운로드뿐만 아니라 버전을 관리하며 스크립트를 실행한다. 예를 들어 서버 시작을 위해 npm start만 입력해서 명령어 전체를 입력하지 않아도 됐었다. 
그러면 Node.js, npm을 더 자세히 알아보며 빌드 도구의 측면에서, 즉 웹 서버 가동이 아닌 유틸리티 스크립트의 측면에서 활용법을 알아보자.
===========================================================================================
482_npm 사용

Understanding npm

Node Package Manager

Isolated Functionality ----------------> Package ----------> npm Repository
    (in Node code)     Share(internally 
                       or externally)
                                               npm CLI--|
                                           |-- npm install <--- Package A
                                           |                    Package B
                                           |                       ...
                                    Some Node Project
npm은 Node Package Manager의 약자로 명령줄 인터페이스다. 터미널 명령줄에 npm에 일정 명령어를 덧붙여 실행하며 주로 npm install을 사용했다.
npm 같은 패키지 및 도구와 모든 프로그래밍 언어는 대개 분리된 기능을 가지고 있다는 개념이 비슷하다. 작성하는 코드가 유용한 역할을 수행한다. 예를 들어 무작위로 숫자를 생성하는 기능을 웹 앱뿐만 아니라 다른앱에도 이용할 수 있다. 독립된 기능이라 프로젝트의 비지니스 논리에 의존하지 않는다. 혹은 공개적으로 공유하고 싶을 수도 있다. 
내부적으로나 외부적으로나 공개하고자 한다면 npm의 도움으로 패키지로 넣을 수 있다. npm을 이용해 패키지 설치에서 나아가 패키지 생성, 공유까지 가능한 것인데 무료로 이용할 수 있는 클라우드 서비스 npm 저장소에서 생성한 패키지를 호스트할 수 있다. npm install 명령어로 패키지를 가져올 수도 있다. 즉, 전역으로 관리되는 이 저장소에서 수많은 패키지를 찾을 수 있다. 내가 작성한 패키지가 아니어도 말이다. 반면 npm에 개인 저장소, 개인 패키지를 가질 수도 있는데 이것은 유료 서비스다.

npm 저장소 관련 공식 페이지에서 명령어를 알아보자. npmjs.com 에 들어가서 패키지를 검색한다. 예를 들어 express 프레임워크를 검색하면 관련 패키지들이 나온다. 클릭해보면 공식 자료와 배포된 버전이 보인다. 특정 버전을 사용하려면 @기호 뒤에 버전을 입력하면 된다. 버전을 생략하면 최신 버전으로 설치된다.
    npm install --save express@4.16.3

해당 패키지가 의존하는 다른 패키지도 볼 수 있다. Express.js를 설치하면 목록에 있는 패키지들은 자동으로 설치되므로 패키지의 디펜던시 역시 Node 모듈에 추가된다. 이처럼 디펜던시의 디펜던시의 디펜던시가 있어서 모듈 폴더는 금방 커진다.

Using npm 메뉴를 보면 중요한 것이 나오는데 npm으로 스크립트 실행이 가능하다는 점이다. npm init 명령어로 npm이 프로젝트를 제어하도록 하면 자동으로 생기는 package.json 파일과 연관이 있다. 여기에 특정 스크립트를 추가할 수 있다. npm start로 스크립트를 시작하거나 npm run 다음 구성한 스크립트 이름을 입력할 수 있다. npm과 Node.js를 이용해 프로젝트 구축 시 유용하다.
React 앱을 예시로 보자. scripts에 build, eject 등은 npm run 다음 입력하여 실행한다. 이들은 제3자 패키지로 디펜던시도 설치됐을 것이다. 
    "dependencies": {
        "react": "^16.5.2",
        "react-dom": "^16.5.2",
        "react-router-dom": "^4.3.1",
        "react-scripts": "2.0.4",
        "socket.io-client": "^4.5.2"
    },
    "scripts": {
        "start": "react-scripts start",
        "build": "react-scripts build",
        "test": "react-scripts test",
        "eject": "react-scripts eject"
    }
===========================================================================================
484_빌드 도구란?

Remember: Node can execute any .js File!

          |----------- Node.js -------------|
Read & Write Files                   Spin up a Web Server
  Parse (read) file
  Manipulate content
  Output new file

Node.js는 주로 웹 서버를 가동(Spin up)하고 서버 측에서 실행되는 코드 작성을 위해 사용했었다. 실제로 나만의 Node.js 앱을 작성할 때 주 용도이기도 하다. 
하지만 이론적으로 Node.js는 모든 자바스크립트 코드를 실행할 수 있다. 구체적으로는 로컬 파일 시스템과도 상호작용할 수 있다. 이것은 새로운 기회를 제공한다. Node.js를 사용하여 예를 들어 특정 파일을 분석한다던가 콘텐츠를 조정하고 조정된 콘텐츠를 원본 또는 새로운 파일로 출력하는 유틸리티 스크립트를 실행할 수 있다. 

what is a "Build Tool"? Any Why?

이것이 빌드 도구라 일컫는 요소의 배경 개념이며 Node.js를 사용해서 진행할 수 있는 작업이기도 하다. 또한 빌드 도구와 빌드 워크플로우에 대해 이야기할 때는 주로 프론트엔드 웹 개발 즉, 예를 들어 리액트 앱을 자주 언급한다. 
우리의 리액트 프로젝트는 Node.js 앱은 아니지만 package.json 파일을 쓰고 npm을 사용하여 패키지를 설치한다. 그러나 이 패키지들은 모두 브라우저에서 실행되는 코드를 지니며 최종적으로 source 폴더에서 작성하는 코드도 브라우저에 위치한다. 하지만 여기에서 작성하는 방식으로는 최소한 모든 브라우저에서 실행되지는 않는다. 예를 들어 다수의 파일에 걸쳐 자바스크립트 코드를 분할하고 ES 모듈의 import 구문을 사용하여 이 파일들을 하나로 통합한다. 이건 최신 브라우저에서만 작동한다. 따라서 이 코드(import FeedPage from '...'))는 브라우저에 도달하지 않는다.
우리는 이 코드를 다루지만 개발 중에는 npm start, 그리고 생산 시 npm run build를 통해 빌드 도구, 빌드 워크플로우를 사용한다. 이 빌드 워크플로우가 코드를 가져다가 함께 통합하여 오래된 브라우저에서도 실행되는 코드로 변환한다. 또한 최소화 및 최적화도 중요하므로 해당 요소들도 반영되어 있다. 

Primarily important in frontend development!

Unoptimized but manageable Code 
    const copy = (arr) =>
    {
        return [...arr];
    }
=> Next-gen Features
    const copy = (arr) =>
    {
        return [...arr];
    }
=> Optimized Code
    var a = function(b)
    {return b.slice()}

빌드 도구를 사용하여 코드를 최적화한다. 위와 같은 형태의 코드를 작성할 수 있는데 실제로 리액트에서는 코드가 이런 형태를 지닌다. 당연히 모든 브라우저에서 실행되지 않고 실행되어도 브라우저에서는 크기가 매우 클 것이다. 왜냐하면 실행에 앞서 모든 코드를 사용자 측에서 다운로드했을 것이고 브라우저에서는 코드를 가능한 한 작게 유지하여 앱과 자바스크립트 코드가 최대한 빠르게 실행되도록 해야한다. 
따라서 최적화된 코드로 마무리하고 싶을 텐데 크기도 클 뿐 더러 스프레드 연산자나 화살표 함수처럼 차세대 기능까지 사용하는 코드가 있어 구형 브라우저에서까지 실행되도록 변환한다. 예시의 더 짧게 최적화된 코드는 길이도 짧고 차세대 자바스크립트 기능도 사용하지 않는다.
이것이 주요 개념이며 프론트엔드 개발에서 매우 중요하다. 왜냐하면 모든 브라우저가 next 기능을 지원하지 않고 코드를 최대한 작게 유지하는 편이 좋기 때문이다. 서버 측에서 이건 그리 중요하지 않다.

리액트 프로젝트로 돌아와서 이 코드를 최적화된 버전으로 변환하려고 한다. npm run build를 실행하면 생산 워크플로우를 시작하는데 최적화된 생산 번들을 생산한다는 것을 의미한다. 이 모든 작업이 스크립트를 시작한 npm을 통해 진행된다. build 폴더를 보면 작성한 소스 코드를 최적화된 방식으로 담아두었다. 
static 폴더의 자바스크립트 코드를 보면 마지막 부분이 우리의 코드이다. 아주 간소화되어 읽기 어렵지만 압축되었고 구형 브라우저에서도 작동하는 논리만을 포함한다. 물론 우리가 이런 식으로 코딩을 할 건 아니고 npm, Node를 사용해 코드를 변환한다.
===========================================================================================
485_빌드 프로세스에서 Node.js 사용

최적화된 코드를 얻는 것은 프론트엔드에서 중요하다. 이때 npm을 설치하여 사용할 수 있다. 이 프로젝트를 관리하고 브라우저에서도 실행되는 패키지를 설치할 수 있다.
개발자로서 Express.js를 이 프로젝트에 설치하지 않아야 하는데 브라우저에서 Express.js를 전혀 사용할 수 없기 때문이다. 
이후 필요한 패키지를 설치하여 파일에 약간 다른 구문을 통해 임포트할 수 있다. 주로 사용되는 프론트엔드 개발에서 ES 모듈 스타일이 적용된 구문이다. 이 스타일은 최신 브라우저에서도 지원된다.
    import { Route, Switch, ... } from 'react-router-dom';
이후 npm을 통해 작업이 완료된다. 패키지를 설치하고 npm으로 스크립트를 시작한다.

npm의 작업이 끝나고 Node.js가 뒤를 잇는다. 노드 모듈 폴더의 react-scripts 패키지를 보자. 여기에도 package.json 파일이 있는 이유는 패키지를 공유할 때도 필요하기 때문이다. 
bin 폴더로 가면 실행되는 일종의 진입점이 있는데 react-scripts.js 코드이다. 이 코드가 최종적으로 실행되는 부분이며 중요한 점이 있다. 이 코드는 최종적으로 Node.js 실행하게 되는데 빌드 워크플로우의 배경 개념은 배포하기에 앞서 개인 컴퓨터에서 최적화된 코드를 서버에 업로드하기 전에 먼저 실행된다는 점이다. 그러니 이 코드는 브라우저 등의 장소에서 실행되지 않는다. 로컬 머신에서 실행될 거여서 Node.js가 실행하게 된다. 또한 이 코드가 최종적으로 실행될 것이고, 다른 스크립트는 다른 코드를 실행하며 로컬 파일 시스템에서 작동한 코드를 실행할 것이다. 예를 들어 scripts 폴더에 build.js 파일이 있는데 다른 기능은 무엇이 있는지 살펴볼 것인데 이건 매우 복잡한 빌드 워크플로우이다. 최종적으로는 프론트엔드 개발에 자주 사용되는 webpack이라는 도구를 써서 빌드 워크플로우를 조율하고 다양한 파일을 컴파일하며 차세대 기능을 잠금 해제하여 또 다른 도구들(babel 등)을 사용하여 기능들을 올바르게 처리할 수 있도록 한다. 여기에서 개념은 Node.js를 사용한다는 것이다.
또한 다른 import, export 구문을 가지고 있으며 다른 패키지들을 로드하여 실행하는데 이 중 몇몇은 최종적으로 우리의 파일, 즉 이 source 폴더에 작성한 로컬 소스 코드를 가져오고 파스(Parse)한 뒤 존재하는 콘텐츠를 변환하고 모두 취합한다. 왜냐하면 최종적으로 많은 파일보다는 하나의 메인 파일과 소수의 파일이 낫기 때문이다. 최적화된 코드를 전부 취합하고 구형 브라우저에서도 실행되는 방식으로 코드를 재작성할 것이다. 이 모든 작업은 배후에서 npm으로 설치한 패키지들을 통해 진행되며 해당 패키지들의 코드는 Node.js로 실행된다.

Node.js 기능을 사용하는 모든 자바스크립트 코드를 머신에서 실행할 수 있으며 유틸리티 스크립트도 실행할 수 있다는 점을 기억하자. 또한 자신만의 유틸리티 스크립트도 작성할 수 있지만 여기에서 유틸리티 스크립트는 소스 코드를 가져다가 우리가 사용하는 패키지에서 정의하는 대로 변환하는 이유는 이 모든 빌드 도구 코드를 직접 작성하고 싶지 않기 때문이다.