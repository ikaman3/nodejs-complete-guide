399_async/await

Asynchronous Requests in a Synchronous Way*
* Only by the way it looks, NOT 

자바스크립트 언어의 새 기능이다. REST API 뿐만아니라 어디에나 자유롭게 사용할 수 있다. 자바스크립트의 핵심 키워드에 해당하며 Node.js 런타임의 전용이 아니다. 또한 최신 브라우저나 프론트엔드 프로젝트에서도 사용 가능하다. 

async와 await은 비동기식 요청을 작성할 수 있게 해주며 이 요청에서는 시간이 다소 소요되고 추후 동기식 방법으로 돌아오는 일부 연산들도 존재한다.
동기식 방법에 * 기호가 붙어있는데 왜냐하면 async와 await은 동기식으로 보이지만 아직 동기식 요청이 아닌 비동기식 문장을 작성하게 해주기 때문이다. 

feed 컨트롤러에 들어가면 비동기식 연산인 Post.find가 보인다. 어떻게 식별할 수 있을까? 
예를 들면 promises를 사용하는 경우를 생각해 보자. Promises는 작동 방식이 유사하기 때문에 비동기식 코드의 취급을 도와주는 전형적인 구조체이다. 
Post.find가 실행되면 countDocuments도 즉각 실행된다. 하지만 그 다음에 countDocuments는 Promise 내지는 이와 유사한 객체를 반환한다. 이후 then을 사용하여 이 연산이 완료된 뒤 실행하는 함수를 정의한다. DB에 접근하기 때문에 일방적으로 좀 더 오래 걸린다. 그래봐야 밀리초 단위지만 즉시 일어나는 건 아니다.
반대로 const currentPage = ..., const perPage = ... 등의 라인은 서로가 실행된 뒤 즉시 실행된다. 이 연산은 거의 시간이 소요되지 않는다. 매우 빠르기 때문에 자바스크립트가 완료를 기다렸다가 다음 단계로 바로 이동할 수 있다. Post.find().countDocument()에서는 완료를 기다리지 않는다. 그렇기 때문에 이 문장 이후에 자바스크립트가 다음 문장을 인라인으로 진행한다. 즉, 만약 Post.find와 동일한 레벨에 다른 문장이 있었다면 그걸 실행한다. console.log 같은 코드가 있었다면 위의 then(...) 블록들의 코드가 실행되기 전에 바로 실행되었을 가능성이 높다. 그 이유는 then을 사용함으로써 더 오래 걸리는 비동기식 연산(Post.find().countDocuments())이 완료된 이후에 실행되는 코드 스니펫이나 함수를 정의하기 때문이다. 또한 즉시 일어나지 않고 조금 시간이 걸리므로 비동기식인 것이다. 

예전에 사용했던 콜백도 비동기식 코드를 사용하는 예시이다. 즉, countDocuments에서 인수를 보면 callback 함수를 정의할 수 있다. then 대신 완료된 뒤 실행할 함수를 정의할 수 있는 것이다. 콜백을 쓰지 않는 이유는 여기서 그 코드를 쓰면 내부의 find 함수에도 콜백이 필요하고 모든 콜백이 중첩되어 콜백 지옥이 펼쳐지기 때문이다. 
따라서 콜백이 가능한 상황에 프로미스를 선호하는 이유는 각각 다음에 1개의 then 블록만 쓰면 되니 가독성이 좋기 때문이다.

async와 await으로 then 블록을 대체할 수도 있다.
============================================================================================
400_then catch - async await 변환

async, await을 사용하기 위해 우선 async 키워드를 화살표 함수 같은 await 키워드를 사용할 예정인 함수 앞에 추가한다.
    exports.getPosts = async (req, res, next) => { ... }

이제 Post.find().countDocuments() 구문은 마치 동기식으로 실행되듯 작성할 수 있다. 새로운 상수 내지는 변수인 totalItems에 await Post.find().countDocuments()을 지정해서 생성하고 then 블록은 지운다.
    const totalItems = await Post.find().countDocuments();

    const posts = await Post.find().populate('creator').skip((currentPage - 1) * perPage)
    .limit(perPage);
다음 구문도 return을 지우고 이후 then 블록에 있던 인수를 변수로 정의한다.

마치 일반 자바스크립트 코드 같다. 그러나 배후에서 async, await은 코드를 가져다가 기존의 then과 유사한 형태로 변환한다. 즉, then을 배후에서 사용해서 안 보이는 것 뿐이다.
await은 배후에서 코드의 변환을 실행하는 것뿐이라는 걸 기억하자. 코드를 가져다가 뒤에 then을 추가하고 해당 연산의 결과를 얻어 totalItems에 저장한 뒤 다음 라인으로 이동해서 암묵적으로 생성된 then 블록 내부에서 실행하는 것이다. 즉, 기존의 코드와 완전히 동일하다. async, await이 배후에서 처리할 뿐이다. 그래서 이건 필수는 아니다. 다만 내용을 이해한다면 선호하는 구문으로 대체할 수 있다.

그렇다면 에러 핸들링은 어떻게 할까? 이제 거의 비동기식 코드처럼 실행되니 try, catch를 사용한다. 위의 코드를 모두 try 블록 안에 넣고 catch 블록에 기존 .catch 블록에 있던 내용을 복사-붙여넣기하면 된다.
    catch (err) {
        if (!err.statusCode) {
            err.statusCode = 500;
        }
        next(err);
    }

테스트해보면 정상적으로 사용할 수 있다.
============================================================================================
401_최상위 await

자바스크립트의 업데이트로 Top Level Await 이라고 칭하는 기능이 추가되었다. 비동기식 함수 외부에서도 await 키워드를 사용할 수 있다. 최상위 레벨에 있는 프로미스를 await할 수 있다. 즉, 함수 내부가 아니다. 이제 여기에서도 await을 사용할 수 있다.
    await
    exports.getPosts = async (req, res, next) => {...}

그러나 async (req, res, next) => {...} 처럼 함수 대신 사용한다면 여전히 async를 추가해야 하므로 이 앱에서 바꿀 것은 없다.
============================================================================================
403_마무리

한 가지 중요한 부분은 async, await을 사용하는 모든 Mongoose 연산에는 Mongoose가 실제로 countDocuments나 find 같은 연산을 진행할 때 프로미스가 아니라 프로미스와 유사한 객체를 반환하며 then, catch, async, await를 사용할 수 있다는 것이다. 실제 프로미스가 아님에도 불구하고 Mongoose가 배후에서 지원하는 것이다. 실제 프로미스에서와 완벽히 동일한 방식으로 async, await을 사용하므로 크게 중요한 것은 아니다.
Mongoose의 연산들 즉, find, countDocuments 같은 연산 뒤에 .exec를 연결하여 프로미스를 사용할 수도 있다. 그러면 실제 프로미스가 반환된다. 하지만 크게 필요하지는 않다.

그러나 암호를 해시하는 bcrypt 라이브러리에서는 실제 프로미스가 위치한다. 전에 then-catch를 쓸 때와 차이점은 없다. async, await은 then, catch의 좋은 대체 수단이다. 더 낫거나 더 빠른 건 아니다. 실질적으로 동일한 코드이다. 읽기 더 쉬울수는 있지만 여전히 비동기식 단계라는 것을 기억하자. 이것 때문에 실행을 차단하거나 자바스크립트 코드 실행 동작이 변하지는 않는다. await 문 뒤에 오는 모든 코드를 then 블록 안에 직접 작성하는 대신 감싸주는 역할이다. 즉, 뒤에 오는 문장이 await이 생성하는 암묵적인 then 블록 내부에서 실행된다.