Which Kind of Application?

Server-side Rendered Views           APIs
Vanilla HTML /             -------| |------- REST / GraphQL
Templating Engine(e.g. EJS)       | |
                                  | |
                              Node Server
                                  +
                            Node Framework(e.g. Express)
                                  |
                            Same Hosting Requirements

지금까지 다양한 앱을 구축했었다. 서버 측 렌더링 된 뷰가 있는 앱을 구축했는데 html 페이지만을 반환하는 것 또는 ejs 같은 템플릿 엔진을 사용하는 것이 포함되며 2개의 API를 구축했었다. REST API, GraphQL API이다. 이러한 2가지 종류의 앱을 하나는 뷰를 포함하고 하나는 제외한 채로 어떻게 배포할까?
먼저 앱이 어떻게 작동하고 들어오는 요청으로 무엇을 진행하는지 어떤 데이터를 받고 반환하는지이다. 최종적으로 기술적 측면에서 보면 2 종류의 앱 모두에서 일반 Node 서버로 시작하여 Node 프레임워크를 사용한다. 따라서 이러한 유형의 앱은 동일한 호스팅 요구 조건을 갖는다. 여기에 차이점을 둘 필요가 없는 이유는 마지막에 코드를 웹 서버로 이동시키면 로컬에서 했던 것과 완전히 동일한 것을 진행하기 때문이다. Node 서버를 시작해서 들어오는 요청을 기다리는 것이다. 따라서 이 2가지 앱을 구분할 필요가 없다.
===========================================================================================
449_배포 준비

Preparing the Code for Production

Use Environment Variables => Avoid hard-coded values in your code
Use Production API Keys => Don't use that testing Stripe API
Reduce Error Output Details => Don't send sensitive info to your users
Set Secure Response Headers => Implement best practices

- Often handled by the Hosting Provider
Add Asset Compression => Reduce Response Size
Configure Logging => Stay up to date about what's happening
User SSL/TLS => Encrypt data in transit

구축하는 앱의 종류를 항상 따라 코드를 준비한다. 일반적으로 Environment Variables(환경 변수)라는 요소를 사용하는 것이 좋다. API 키, 포트 번호, 암호 등의 특정 값을 코드에 하드코딩하는 대신 환경 변수를 사용하는 것이다. 
또한 Stripe 등의 제3자 서비스를 사용하는 경우 개발 키가 아니라 생산 API키를 사용해야 한다.
오류를 처리하거나 뭔가를 로그하기 위한 매커니즘도 있다. 오류 출력값에 관한 세부 사항을 줄이려고 할 것이다. 민감한 정보를 사용자에게 발신하는 것을 막기 위해서다. 어딘가 고장 혹은 오류 메시지가 출력된다면 최대한 적은 정보를 포함하도록 하는 편이 좋은 이유는 웹사이트의 사용자들이 우리의 소스 코드를 파악해서는 안 되기 때문이다. 기본적으로 이 프로젝트에서는 이에 관한 문제는 없다. 기본값 오류 표시 처리 미들웨어를 사용하고 기본값 오류와 사용자 설정 오류에 민감한 정보가 담겨있지 않다면 괜찮기 때문이다.
앱이 발신하는 응답과 관계없이 반드시 완전한 응답 헤더를 설정해 두어야 한다. 일부 응답 헤더들은 모든 응답에 추가해도 안전하며 클라이언트가 특정 작업을 하는 것을 막아주기도 한다. 
일반적인 Node 앱에서는 일부 에셋으로 JavaScript, CSS 파일도 서비스할 수 있다. 그리고 여기에서 압축을 추가하는 것이 좋은데 왜냐하면 응답 크기를 줄임으로써 클라이언트가 적게 다운로드해도 되므로 응답 시간 또한 줄여주기 때문이다. 대부분의 현대 브라우저 등등은 압축된 상태로 다운로드할 수 있다. 즉, 압축된 에셋을 받아 브라우저에서 바로 압축 해제할 수 있다. 
로그 기록을 구성하여 서버에서 일어나는 일을 인지하는 게 좋다. 더 이상 서버 테스트가 아닌 실제 사용자들이 상호작용하므로 상호작용을 로그 파일로 기록하여 원할 때마다 열람하는 것이 좋다.
마지막으로 SSL/TLS 즉 이동 중인 데이터의 암호화를 살펴보아야 한다. 지금까지 일반 http 서버를 사용했었고 따라서 서버와의 통신이 암호화되지 않았는데 테스트 목적에서는 괜찮다. 생산 준비된 앱의 경우 연결을 암호화하는 것을 권장한다.
또한 마지막 세 가지 요소들(압축, 로그 기록 및 SSL)은 호스트 제공자에서 종종 취급된다는 걸 알아두자. 일반적으로 이 요소들도 관리되는 서비스를 사용하여 크게 신경 쓸 필요가 없도록 하는게 좋기 때문이다.
===========================================================================================
450_환경 변수 사용

맨 처음 프로젝트로 돌아온다. REST API도 아니고 GraphQL API도 아닌 뷰를 렌더링하는 쇼핑몰 앱이다. app.js 파일에서 시작한다. 
우선 환경 변수란 뭘까? Node.js에서 지원하는 개념으로 특정 구성이나 값을 외부에서부터 Node 앱으로 전달하여 Node 코드에 특정 값을 하드코딩할 필요가 없게 해 준다. 대신 Node 서버가 시작할 때 해당 값들이 자동으로 입력된다. 이를 통해 개발 및 생산에서 다양한 값들을 사용할 수 있게 하고 전체 코드를 재배포하는 일 없이 생산에서 값을 편하게 변경할 수 있다. MongoDB Connection String이 좋은 예시인데 이 문자열은 Mongoose 클러스터에 연결할 수 있게 해준다. 현재 하드코딩 되어 있다. 만약 여기서 뭔가를 변경하려고 하면 코드 자체를 수정하고 재배포해야 한다. 이 코드를 누군가와 공유한다면 이 자격 증명을 알게 된다.
맨 밑의 코드가 시작할 포트를 설정하는데 개발에서는 3000을 사용하며 1000 범위를 넘기만 하면 어떤 숫자든지 사용할 수 있다. 그러나 Production의 경우 우리의 서버나 호스트 제공자(Hoting Provider)가 이 포트를 설정하게 두는 편이 좋은데 왜냐하면 이를 통해 서비스가 최종적으로 이 앱을 웹으로 공개하게 되며 모든 네트워크 설정을 구성하기 때문이다. 따라서 포트 번호를 우리가 조절하는 대신 서비스 제공자 측에서 하게 된다. 
환경 변수를 사용해 볼 또 다른 예시는 컨트롤러 폴더의 shop.js 파일의 Stripe API 키 등이 있다. 이건 생산 키로 대체해야 할 개발용 키이지만 Mongoose 데이터에서와 동일한 이유로 하드코딩한다는 건 그리 좋은 생각이 아니다. 

먼저 MONGODB_URL을 백틱을 사용해 템플릿 리터럴로 변경한다. 여전히 일반 문자열이지만 값을 인젝트할 수 있다. 이제 process 객체에서 환경 객체에 접근할 수 있다. 이것은 우리가 정의한 객체는 아니지만 Node App 전체에서 사용 가능하다. Node의 핵심 런타임 일부에 해당한다. 이 process 객체에는 env 속성이 있는데 이 Node process가 아는 모든 환경 변수를 포함한 객체다. 다양한 디폴트 환경 변수가 있지만 직접 설정할 수도 있다.

    const MONGODB_URI = `mongodb+srv://${process.env.MONGO_USER}:${process.env.MONGO_PASSWORD}@cluster0.bcol3h1.mongodb.net/${process.env.MONGO_DEFALUT_DATABASE}`;
- 이 전체 문자열도 해당 문자열이 규칙적으로 변하는지에 따라 전체를 변경할 수도 있고 내부의 값만 변경할 수도 있다. 
    app.listen(process.env.PORT || 3000);
- 포트 넘버는 정의되지 않으면 3000으로 한다. 이걸 관리해 주는 호스트 제공자는 자동으로 포트 넘버를 입력한다. 즉, 대부분의 경우 설정되는 대로 따라가며 로컬 개발의 경우 설정되지 않기 때문에 계속 3000을 사용할 것이다.
    const stripe = require('stripe')(process.env.STRIPE_KEY);
- 컨트롤러 폴더의 shop.js 파일에서 stripe 키도 바꾼다.

이제 Node 코드에 있는 이 환경 변수들을 읽어야한다. 어떻게 Node에 전달할까? Node 앱을 실행할 때 이루어진다. nodemon을 사용하면 구성 파일을 제공할 수 있다. 프로젝트의 루트 폴더에 nodemon.json 파일을 추가한다. 여기에 코드에서 읽으려고 한 모든 변수의 실제 값을 입력한다.  
nodemon.json =>
    {
        "env": {
            "MONGO_USER": "...",
            "MONGO_PASSWORD": "...",
            "MONGO_DEFALUT_DATABASE": "...",
            "STRIPE_KEY": "..."
        }
    }

이제 npm start로 서버를 시작하면 정상적으로 작동해야 한다.

항상 nodemon을 사용하진 않고 특히 이 앱을 배포할 때는 안 쓸 텐데 왜냐하면 어차피 코드를 변경하지 않으므로 매번 변경할 때마다 서버를 재시작하고 싶지 않기 때문이다. 따라서 새로운 start 스크립트를 package.json 파일에 추가한다.
package.json =>
    "scripts": {
        "start": "NODE_ENV=production ... node app.js",
        ...
        "start:dev": "nodemon app.js"
    },
- 이름은 아무거나 상관없다. 여기엔 nodemon을 사용하고 메인 start 스크립트에는 node를 사용하려 한다.
- 메인 start 스크립트에서는 nodemon.json 파일을 쓰지 않기 때문에 환경 변수를 전달하려면 다른 솔루션들이 있다. 또한 호스트 제공자를 사용한다면 호스트 제공자의 대시 보드에서 환경 변수를 설정할 수 있다. 일단 간단한 솔루션으로 설정하려는 키 값 쌍을 가져다가 start 스크립트 앞에 추가한다. MONGO_USER=max MONGO_PASSWORD=... 이런 식으로 입력한다. 띄어쓰기로 구분한다.

수동으로 설정할 수 있는 특별한 환경 변수 하나는 NODE_ENV 이다. 이건 기본으로 설정되지 않았음에도 특별한 환경 변수인데 Express.js가 환경 모드를 정의하기 위해 기본값으로 이걸 사용하기 때문이다. 그리고 이걸 production으로 설정하면 Express.js가 몇 가지를 변경하는데 예를 들면 출력하는 오류의 세부 사항을 줄이며 일반적으로는 배포를 위해 몇 가지를 최적화한다.  
app.js =>
    console.log(process.env.NODE_ENV);
서버를 재시작해보면 undefined가 출력되는데 이건 호스트 제공자들이 자동으로 설정한다. package.json에 위의 방법으로 직접 설정할 수도 있다.
===========================================================================================
452_Helmet으로 보안 응답 헤더 설정

Helmet이라는 제3자 패키지를 사용해 보안 헤더를 설정할 것이다. 최종적으로 이 패키지는 반환한 응답에 특정 헤더를 추가하고 모범 사례를 따른다.
    npm install --save helmet
다운로드하고 미들웨어로 포함하면 자동으로 모든 들어오는 요청에 대해 실행된다. 
    const helmet = require('helmet');
    ...
    app.use(helmet());
다른 미들웨어들이 모두 설정되는 위치에 작성하고 함수로 실행한다.

브라우저의 Network 탭을 보면 응답에 몇 개의 헤더가 설정되었는지 볼 수 있다. helmet을 설정하면 몇 개의 헤더가 추가된다. 
===========================================================================================
453_에셋 압축

    npm install --save compression
설치하고 app.js 파일에서 임포트한다. 그리고 helmet 미들웨어 다음에 추가하고 함수로 실행한다.
    const compression = require('compression');
    ...
    app.use(compression());

브라우저의 Network 탭에서 main.css, main.js 파일을 보면 에셋의 크기가 줄어든 것을 볼 수 있다. 코드를 다량 서비스해야 하는 앱이나 일반적으로 많은 파일을 제공하는 경우 고려할 만한 가치가 있다.
참고로 이미지 파일은 압축하지 않는데 왜냐하면 그럴 경우 로드하는데 시간이 더 오래 걸리기 때문이다.

대부분의 호스트 제공자들은 압축 지원이 일부 내장되어 있거나 최소한 이 압축 지원을 제공하여 쉽게 추가할 수 있도록 해준다. 따라서 즉시 에셋을 압축해 주니 직접 미들웨어를 사용할 일은 없을 것이다. 사실 만약 호스트 제공자 측에서 지원한다면 직접 압축하면 안 된다. 그러나 호스트 제공자가 지원하지 않거나 직접 서버를 구축하는 경우 추가하기에 좋은 미들웨어이다.
===========================================================================================
454_요청 로깅 설정

압축과 헤더 뿐만아니라 로그 기록도 중요하다. 이를 위해 패키지를 설치한다. 
    npm install --save morgan

    const morgan = require('morgan');
    ...
    const accessLogStream = fs.createWriteStream(
        path.join(__dirname, 'access.log'), 
        { flags: 'a' }
    );
    app.use(morgan('combined', { stream: accessLogStream }));
- 미들웨어를 설정하고 함수로 실행한다. 그리고 이 함수에 어떻게 로깅할지에 관한 정보를 전달한다. 첫 번째 매개변수만 설정하면 서버의 콘솔에 로그를 출력한다. 
- 일반적으로 파일에서 보는 게 좋으므로 두 번째 매개변수도 설정한다. 새로운 상수인 accessLogStream를 생성한다. 여기에 createWriteStream으로 쓰기 스트림을 생성하고 path_join으로 현재 폴더에서 보는 경로를 정의하고 access.log라는 파일을 생성하여 이 파일에 로그 기록을 작성할 수 있다. 그 뒤에 구성을 추가하는데 flags를 덧붙임을 뜻하는 'a'(append)로 설정하여 새 데이터가 기존 파일을 덮어쓰지 않고 해당 파일의 끝부분에 덧붙여서 계속해서 로그가 파일에 추가되도록 한다. 
- 위에서 설정한 스트림을 morgan에 전달한다.

morgan 함수에 매개변수로 다양한 설정을 전달하여 로그를 커스터마이징할 수 있다. 물론 대부분의 호스트 제공자에서 로깅 기능을 제공하므로 필요없을 수도 있지만 알아두자.
===========================================================================================
456_SSL 서버 설정

Using SSL/TLS

                                   binds key to Identity
       |-----------SSL Certificate <-------------------- Public Key
  Public Key            Decrypt
       |               |-------- Private Key 
    Client <========= Data =========> Server
                       ^
                       | SSL/TLS Encryption
                       | Eavesdropping
                       |
                    Attacker

TLS는 단순히 좀 더 새로운 버전이다. 둘 다 클라이언트에서 서버로 전송되는 데이터를 보호하는 것에 대한 요소이다. 왜냐하면 클라이언트와 서버 간 통신 시 일반적으로 데이터를 교환하게 된다. 공격자(Attacker), 즉 해당 데이터를 염탐하는 제3자가 기술적으로 존재할 수 있다. 이 공격자는 클라이언트에서 서버로 전송되는 데이터를 읽을 수 있어 신용카드 데이터 등과 관련해서는 문제가 될 수 있다. 따라서 데이터를 보호하기 위해 SSL/TLS 암호화를 사용한다.
암호화가 적용된 뒤에는 더 이상 염탐이 불가능한데 데이터가 이동 중에는 읽을 수 없게 되며 서버에서 해독되기 때문이다. 

암호화와 해독을 가능하게 하려면 공개, 비공개 키 쌍(Public Key, Private Key)을 다루게 된다. 양쪽 다 서버에 알려져 있다. 
공개 키는 이름처럼 보호할 요소가 아니다. 그러나 비공개 키는 서버에서만 알아야 하며 나중에 복호화에 사용된다. 공개 키는 암호화에 사용된다. 
SSL 인증서에서는 해당 공개 키를 서버의 신원에 결합하게 된다. 서버의 신원은 단순히 말하자면 도메인이나, 관리자의 이메일 주소 등으로 인증서를 생성할 때 설정하는 데이터이다. 따라서 SSL 인증서는 공개 키와 서버를 연결하고 이를 클라이언트와 브라우저로 전송되어 클라이언트 또한 공개 키를 인지하고 해당 키가 해당 서버에 속한다는 걸 알게 한다. 
일반적으로 인증서 권한을 사용하나 자신만의 SSL 인증서를 생성하는 것도 가능하다. 그러나 자신만의 키를 생성하는 경우 브라우저는 내부의 정보가 정확할 것이라고 신뢰하지 않는다. 그런 경우 '이 페이지는 SSL을 사용하지만 안전하지 않습니다. 정말 방문하시겠습니까?' 등의 경고 문구를 보게 된다. 따라서 Production에서는 브라우저가 신뢰하는 알려진 인증서 권한을 통해 제공되는 SSL 인증서를 사용하여 실제로 안전하고 신뢰할 수 있는 보호를 받는다. 
작동 방식은 항상 동일하다. 해당 인증서의 일부로 공개 키가 존재하고 인증서는 우리가 아닌 신뢰할 수 있는 기관에서 생성한다.
이 공개 키는 이후 클라이언트가 인증서를 통해 수신하게 된다. 그 뒤에 클라이언트는 서버로 전송하는 데이터를 암호화할 수 있으며 서버는 해당 비공개 키를 사용하여 데이터를 해독할 수 있다. 해당 비공개 키만이 해당 데이터를 해독할 수 있다. 

인증서를 생성하기 위해 openssl 이라는 명령어를 사용한다. Mac과 Linux에서는 기본값으로 제공되지만 Windows는 프로그램을 설치해야 한다.
    openssl req -nodes -new -x509 -keyout server.key -out server.cert
이를 통해 인증서에 포함되어 있는 비공개 키와 공개 키가 제공된다. 몇 가지 질문에 답해야 하는데 어차피 직접 생성한 인증서는 브라우저에서 허용하지 않으므로 적당히 입력한다. 다만 Common Name은 localhost로 설정한다. 그렇지 않으면 도메인으로 설정해야 해서 인증서가 작동하지 않는다. 따라서 직접 서명한 인증서를 앱을 배포할 서버에 사용하게 되고 이 앱을 example.com에서 호스트 한다면 여기도 example.com으로 설정해야 한다. 

설정을 마치면 server.cert, server.key 파일이 생성된다. cert는 인증서이고 key는 비공개 키다. 최종적으로 서버에 전송하는 건 인증서 부분이다. 비공개 키는 항상 서버에 남아있다.
app.js에서 https 서버를 가동하게 허용하는 https 모듈을 임포트한다. 지금까지는 app.listen을 통해 직간접적으로 http를 사용했지만 https를 사용할 것이다. 
app.js =>
    const https = require('https');
    ...
    const privateKey = fs.readFileSync('server.key');
    const certificate = fs.readFileSync('server.cert');
    ...
    https.createServer({key: privateKey, cert: certificate}, app).listen(process.env.PORT || 3000);
- node 파일 시스템 패키지를 사용하여 privateKey를 읽어온다. 이때 동기식을 사용하는데 파일을 읽을 때까지 코드 실행을 차단하게 되며 해당 파일을 읽기 전까지 서버 시작을 진행하지 않게 된다. 
- 이제 app.listen 대신 https를 사용하며 https 서버를 생성하기 위해 createServer를 입력한다. 여기엔 인수가 2개 필요하다. 첫 번째 인수는 서버를 구성하는데 우리의 비공개 키와 인증서를 지정해야 한다. 첫 번째 인수는 자바스크립트 객체로 두 가지를 설정한다. 두 번째 인수는 요청 핸들러이며 이 경우 Express 애플리케이션이 된다. 따라서 두 번째 인수는 우리의 app이 된다.
- 이후 해당 서버에서 듣는다(Listen). 

브라우저에서 기존처럼 localhost:3000으로 접속하면 기본값으로 http를 사용하여 실패한다. https://localhost:3000을 사용하면 직접 서명한 인증서를 받아주지 않아서 실패한다. 고급 옵션에서 무시하고 진행하기를 눌러 접속할 수 있다. 브라우저가 경고를 띄우지만 엄밀히 말해 SSL 보호를 사용하는 중이다.

하지만 이러한 설정은 호스트 제공자 측에서 설정할 텐데 왜냐하면 제공자가 서버를 보유하고 있고 호스트 제공자의 서버는 이후 SSL과 앱 간의 트래픽을 사용한다. 그리고 공개되어 있지 않기 때문에 그 사이에 서버가 http를 사용하며 호스트 제공자 프론트 서버가 이 논리를 구현할 것이다. 따라서 해당 코드를 직접 작성할 일은 없다.
그러므로 app.listen을 사용하는 기존 코드로 원상복구 한다. 호스트 제공자가 SSL을 관리하니 나중에 배포할 때 필요하기 때문이다. 
===========================================================================================
457_Hosting Provider 사용하기

* 강의에서는 Heroku를 사용하였으나 프리티어 서비스가 종료되어 사용하지 않을 것임.

Using a Hosting Provider

                    |------------------- <Your Code>
                    |                       
                    |                     Gateway, public Server
            Virtual Server / ===> Managed =====================>  Your Users
            Managed Space    <=== Servers <=====================
            Private Network     SSL, Compression
            No external Access  Logging, Load Balancing

호스팅 제공업체의 대안은 직접 컴퓨터를 설정해서 인터넷에 연결되도록 올바른 포트를 노출함으로써 사람들이 우리의 방에서 실행되는 컴퓨터에 요청을 보낼 수 있게 하는 것이다. 하지만 전문가가 아닌 이상 추천하지 않는다. 불안정할 확률이 높고 확장성이 결여될 수도 있기 때문이다. 앱이 잘 된다면 계속해서 새 컴퓨터가 필요하게 되고 점점 더 복잡하고 비싸질 것이다. 따라서 보통 Heroku, AWS 같은 호스팅 제공업체를 사용한다.
그러면 가지고 있던 코드를 업체의 관리 공간, 즉 가상 서버에 배포한다. 호스팅 제공업체의 데이터 센터에 있는 기계의 성능이 좋아야 할 것이다. 이때 기계 하나를 통째로 빌릴 수도 있지만 보통은 하드 드라이브의 일부와 리소스 일부만 빌려서 관리 공간으로 공급하는데 같은 서버 같은 컴퓨터에서 실행되는 다른 앱과는 완전히 분리되어 실행된다. 
이제 가상 서버에서 실행되는 앱을 사용자와 연결한다. 대개 서버와 기계 상의 관리 공간을 직접적으로 연결하지는 않는다. 일부 호스팅 제공업체는 가능하지만 대부분의 제공업체는 많은 작업을 대신 수행하며 우리의 서버 전에 업체가 관리하는 서버를 두어서 편리하게 SSL 암호화, 압축, 로그인, 로드 밸런싱 등을 추가할 수 있다.-로드 밸런싱이란 앱이 아주 유명해져서 더 많은 리소스를 위해 여러 가상 서버를 가지게 되면 들어오는 요청을 효율적으로 사용 가능한 서버에 보내주는 기능을 말한다-소위 말하는 Managed Servers(관리 서버)가 배후에서 처리한다. 호스팅 제공업체가 제공하는 UI를 통해 SSL, 로그인 등에서 앱이 어떻게 작동할지 설정한다. 
이때 모든 과정이 전용망에서 실행되는데 가상 서버나 코드가 웹에 직접 노출되지 않고 관리 서버에 노출되어 웹에 나타난다는 뜻으로 공공 서버 게이트웨이를 통해 사용자에 노출된다. 게이트웨이는 문과 같아서 요청이 들어오고 가상 서버로 보내지며 응답 역시 게이트웨이를 통해 전달된다. 
===========================================================================================
458_프로젝트와 GIT 설정

Heroku에 회원가입하고 정보를 입력한다. 이때 Deployment method는 Heroku Git 으로 설정한다. 

Version Control (Git)

                       Save & Manage Your Source Code
Commits: "Snapshots" of your code / Easily switch between commits / Create commit after bugfixes, new features
Branches: Different "versions" of your code / e.g. master(production), development, new-feature / Separate development of new features and bugfixing
Remote Repositories: Store code + commits + branches in the cloud / Protect against loss of local data / Deploy code automatically

Git이란 Heroku가 사용하는 툴로 버전 컨트롤 시스템으로 사용하는 툴이다. 선택 사항이지만 소스 코드를 저장하고 관리하는 데 유용하다. 여러 기능을 다룰 수 있는데 그 중 커밋, 브랜치, 원격 저장소가 대표적이다. 
커밋은 코드의 스냅샷과 같아서 예전 버전의 코드로 돌아가 살펴본 후 다시 최근 버전으로 돌아오거나 이전 버전으로 돌아갈 수 있다. 버그 수정 후, 새 기능 추가 후 등에 커밋을 생성한다.
브랜치는 하나의 스냅샷이 아닌 여러 버전의 스냅샷을 가지도록 해 생상 준비를 마친 마스터 브랜치와 버그를 추가하고 새 기능을 추가할 다른 브랜치를 분리해 메인 코드를 손상시키지 않도록 한다. 새 기능을 추가하고 나면 해당 브랜치와 마스터 브랜치를 Merge(병합)하여 생산을 위한 브랜치를 하나만 유지한다. 다시 말해 완성된 코드에 영향을 주지 않으면서 여러 브랜치에서 다양한 기능을 테스트해 볼 수 있도록 개발 워크플로우를 분리해 생산 워크플로우와 다른 기능 워크플로우로 나눈다.
원격 저장소는 디폴트로 코드를 저장하는 로컬 저장소에서 나아가 코드, 커밋, 브랜치를 클라우드에 저장하는 걸 말한다. 따라서 로컬 데이터가 손실되는 것을 방지하고 여러 머신에서 소스 코드에 접근하고 다른 개발자와 공유할 수 있다. 이를 통해 코드를 자동으로 배포할 수 있는데 바로 Heroku를 원격 저장소로 사용하는 것이다. 코드를 원격 저장소인 Heroku로 푸시하면 Heroku가 코드를 생산에 적용해 서버가 자동으로 해당 코드에 기반해서 돌아간다. 
===========================================================================================
459_Heroku를 사용한 배포 예시

Heroku CLI를 알아보자 Heroku에 국한된 설명이며 다른 호스팅 제공 업체의 경우 간단하게 코드를 드래그 앤 드롭해서 배포할 수 있다. Git, Heroku CLI를 설치하여 준비한다.
그리고 일반 Terminal 이나 명령 프롬프트에 명령어를 실행한다.
    heroku login
- 미리 생성한 계정 데이터로 로그인한다. 이메일을 입력한다.
    cd my-project
    git init
    heroku git:remote -a project-name
- 코드베이스, 즉 지금까지 작업했던 프로젝트를 Git 저장소로 전환한다. 원격 Git 저장소로 Heroku를 추가 및 배포하는 명령어다. 이미 Git 저장소가 있다면 git init은 생략한다. 그럼 원격 프로젝트로 추가되고 원격 프로젝트 URL을 로컬 코드베이스의 원격 저장소로 설정한다. 

이제 package.json 파일로 가서 "scripts" 위에 새 항목 "engines"를 추가해 "node"에 사용 중인 Node.js 버전을 입력한다. 터미널에 node -v 를 실행하여 알 수 있다. 어떤 버전을 사용하든 간에 "node"에 정보를 입력하면 배포에 사용할 원격 서버에 설치할 때 해당 버전을 사용한다. 
    "engines": {
        "node": "18.9.1"
    },

app.js에서 compression을 사용하는지 확인한다. Heroku는 다른 업체와 다르게 즉각적인 압축을 지원하지 않아서 직접 압축을 설정해야 한다. 
또 SSL을 위한 certificate, privateKey를 읽지 않도록 주석 처리하여 배포되지 않도록 한다. SSL을 사용하지 않으니 HTTPS 서버도 실행하면 안 된다. Heroku의 관리 서버를 통해 배포를 할 예정이므로 일반적인 HTTP 서버로 Rollback 한다. 

루트 폴더에 확장자 없이 Procfile 파일을 생성한다.
Procfile =>
    web: node app.js
- 앱을 시작할 때 app.js 파일을 실행하도록 Heroku에 알린다. 

.gitignore 파일을 생성하여 스냅샷에 포함하지 않을 폴더를 Git에 알린다. 
server.cert, server.key, node_modules 등이 있는데 특히 node_modules는 모든 제3자 패키지가 저장된 폴더라 배포하지 않는 게 좋다. 전송할 데이터의 크기만 늘릴 뿐이다. 게다가 Heroku를 포함해 모든 호스팅 제공업체는 코드를 배포한 뒤 node_modules 파일을 재생성해 서버에 디펜던시를 설치한다. 

    git add .
    git commit -am "message you want"
    git push heroku master
- 새 스냅샷, 즉 커밋을 생성해 코드를 Heroku로 푸시한다. 

그대로 설정하면 환경 변수가 디폴트인 NODE_ENV를 제외하고 전달되지 않기 때문에 직접 설정해야 한다. 대시보드의 Settings의 Config Vars에 직접 앱에 전달된 환경 변수를 추가한다. 하나씩 키-값 쌍으로 추가할 수 있다.

MongoDB의 설정도 변경해야 한다. MongoDB Atlas의 Security 탭 아래 연결이 허용된 IP Whitelist가 있다. 실행 중인 앱의 IP를 화이트리스트 설정한다. Heroku 기본 버전에선 프로젝트에 지정된 고정 IP 주소가 없고 다양한 범위 내에서 바뀐다. 이렇게 IP 범위가 넓을 때는 ADD IP ADDRESS에 모든 접근을 허용한다. 사용자명과 비밀번호가 있어서 안전하기는 하지만 고정 IP 주소를 지정해서 더 안전하게 하는 것을 권장한다.

===========================================================================================
460_사용자 생성 파일을 Heroku에 저장하기

Heroku에 앱을 호스팅할 때 한 가지 주의할 점이 있다. 보통 사용자가 생성하거나 업로드한 이미지는 의도한 대로 저장되고 제공된다. 하지만 가상 서버를 제공하는 모든 호스팅 제공업체들과 같이 파일 스토리지가 지속되지 않는다.
소스 코드는 저장되어 서버를 종료하거나 절전 모드에 들어가면 재배포가 된다. (Heroku 무료 버전에서는 가끔 서버가 자동으로 절전 모드에 돌입한다.) 반면 생성하거나 업로드한 파일은 저장되거나 재생성되지 않는다. 서버를 재시작하면 손실된다는 뜻이다. 따라서 이러한 호스팅 제공업체 이용 시, 별도의 스토리지를 이용하는 것을 권장한다.
만약 우리가 소유하고 관리하는 서버에 실행한다면, 적용되지 않는 사항이다.

다른 대안은 무엇일까? 바로 AWS S3 (Simple Storage Service)가 효율적이고 가격이 적당해서 많이 사용한다. https://aws.amazon.com/s3/
다음 패키지를 통해 쉽게 multer를 구성해 파일을 저장할 수 있다. https://www.npmjs.com/package/multer-s3
파일을 제공하기 위해서는 s3-proxy 같은 패키지를 이용한다.  https://www.npmjs.com/package/s3-proxy
파일을 삭제하거나 자체적으로 상호 작용하기 위해서는 AWS SDK를 이용한다.  https://aws.amazon.com/sdk-for-node-js/
===========================================================================================
461_API 배포

지금 다루는 것은 REST API, GraphQL API가 아닌 쇼핑몰 앱이었다. 하지만 API 배포는 큰 차이가 없으므로 완전히 똑같은 방식으로 배포할 수 있다. 한 가지 다른 점은 Open app 버튼을 클릭하면 시작 페이지에 내용이 없다는 것이다. 서버 측에서 렌더링 된 뷰가 없기 때문이다. 대신 실행되는 API에 요청을 보낼 수 있고 프론트엔드 앱 및 모바일 앱에서 요청을 보내는 URL을 로컬 호스트에서 현재 실행되는 호스트 앱에 보내도록 조정하면 된다. 즉, 앱에서 URL을 localhost가 아닌 호스트 도메인으로 변경하는 것이다.

한편 프론트엔드 앱 및 모바일 앱은 어차피 다르게 배포된다. 모바일 앱은 앱스토어를 통해 사용자에게 보내지고 강의에서 한 것처럼 React로 구축한 프론트엔드 앱은 보통 정적 웹 앱으로 배포된다. 이러한 프로젝트는 package.json에서 찾을 수 있는 build 스크립트를 통해 구축할 수 있으며 이 경우 npm run build 를 실행하면 이미 구축되어 최적화된 코드가 있는 폴더가 자동으로 생성된다. 그럼 코드를 build 폴더에 가져가 AWS S3 같은 정적 웹 포스트로 전달한 후 노드 앱이 실행되는 서버와 완전히 다른 서버에서 앱을 실행한다. 지금까지 배웠듯이 노드 API와 프론트엔드 모바일 앱 사이에 큰 상관관계는 없기 때문이다. 