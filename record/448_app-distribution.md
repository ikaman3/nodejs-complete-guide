Which Kind of Application?

Server-side Rendered Views           APIs
Vanilla HTML /             -------| |------- REST / GraphQL
Templating Engine(e.g. EJS)       | |
                                  | |
                              Node Server
                                  +
                            Node Framework(e.g. Express)
                                  |
                            Same Hosting Requirements

지금까지 다양한 앱을 구축했었다. 서버 측 렌더링 된 뷰가 있는 앱을 구축했는데 html 페이지만을 반환하는 것 또는 ejs 같은 템플릿 엔진을 사용하는 것이 포함되며 2개의 API를 구축했었다. REST API, GraphQL API이다. 이러한 2가지 종류의 앱을 하나는 뷰를 포함하고 하나는 제외한 채로 어떻게 배포할까?
먼저 앱이 어떻게 작동하고 들어오는 요청으로 무엇을 진행하는지 어떤 데이터를 받고 반환하는지이다. 최종적으로 기술적 측면에서 보면 2 종류의 앱 모두에서 일반 Node 서버로 시작하여 Node 프레임워크를 사용한다. 따라서 이러한 유형의 앱은 동일한 호스팅 요구 조건을 갖는다. 여기에 차이점을 둘 필요가 없는 이유는 마지막에 코드를 웹 서버로 이동시키면 로컬에서 했던 것과 완전히 동일한 것을 진행하기 때문이다. Node 서버를 시작해서 들어오는 요청을 기다리는 것이다. 따라서 이 2가지 앱을 구분할 필요가 없다.
===========================================================================================
449_배포 준비

Preparing the Code for Production

Use Environment Variables => Avoid hard-coded values in your code
Use Production API Keys => Don't use that testing Stripe API
Reduce Error Output Details => Don't send sensitive info to your users
Set Secure Response Headers => Implement best practices

- Often handled by the Hosting Provider
Add Asset Compression => Reduce Response Size
Configure Logging => Stay up to date about what's happening
User SSL/TLS => Encrypt data in transit

구축하는 앱의 종류를 항상 따라 코드를 준비한다. 일반적으로 Environment Variables(환경 변수)라는 요소를 사용하는 것이 좋다. API 키, 포트 번호, 암호 등의 특정 값을 코드에 하드코딩하는 대신 환경 변수를 사용하는 것이다. 
또한 Stripe 등의 제3자 서비스를 사용하는 경우 개발 키가 아니라 생산 API키를 사용해야 한다.
오류를 처리하거나 뭔가를 로그하기 위한 매커니즘도 있다. 오류 출력값에 관한 세부 사항을 줄이려고 할 것이다. 민감한 정보를 사용자에게 발신하는 것을 막기 위해서다. 어딘가 고장 혹은 오류 메시지가 출력된다면 최대한 적은 정보를 포함하도록 하는 편이 좋은 이유는 웹사이트의 사용자들이 우리의 소스 코드를 파악해서는 안 되기 때문이다. 기본적으로 이 프로젝트에서는 이에 관한 문제는 없다. 기본값 오류 표시 처리 미들웨어를 사용하고 기본값 오류와 사용자 설정 오류에 민감한 정보가 담겨있지 않다면 괜찮기 때문이다.
앱이 발신하는 응답과 관계없이 반드시 완전한 응답 헤더를 설정해 두어야 한다. 일부 응답 헤더들은 모든 응답에 추가해도 안전하며 클라이언트가 특정 작업을 하는 것을 막아주기도 한다. 
일반적인 Node 앱에서는 일부 에셋으로 JavaScript, CSS 파일도 서비스할 수 있다. 그리고 여기에서 압축을 추가하는 것이 좋은데 왜냐하면 응답 크기를 줄임으로써 클라이언트가 적게 다운로드해도 되므로 응답 시간 또한 줄여주기 때문이다. 대부분의 현대 브라우저 등등은 압축된 상태로 다운로드할 수 있다. 즉, 압축된 에셋을 받아 브라우저에서 바로 압축 해제할 수 있다. 
로그 기록을 구성하여 서버에서 일어나는 일을 인지하는 게 좋다. 더 이상 서버 테스트가 아닌 실제 사용자들이 상호작용하므로 상호작용을 로그 파일로 기록하여 원할 때마다 열람하는 것이 좋다.
마지막으로 SSL/TLS 즉 이동 중인 데이터의 암호화를 살펴보아야 한다. 지금까지 일반 http 서버를 사용했었고 따라서 서버와의 통신이 암호화되지 않았는데 테스트 목적에서는 괜찮다. 생산 준비된 앱의 경우 연결을 암호화하는 것을 권장한다.
또한 마지막 세 가지 요소들(압축, 로그 기록 및 SSL)은 호스트 제공자에서 종종 취급된다는 걸 알아두자. 일반적으로 이 요소들도 관리되는 서비스를 사용하여 크게 신경 쓸 필요가 없도록 하는게 좋기 때문이다.
===========================================================================================
450_환경 변수 사용

맨 처음 프로젝트로 돌아온다. REST API도 아니고 GraphQL API도 아닌 뷰를 렌더링하는 쇼핑몰 앱이다. app.js 파일에서 시작한다. 
우선 환경 변수란 뭘까? Node.js에서 지원하는 개념으로 특정 구성이나 값을 외부에서부터 Node 앱으로 전달하여 Node 코드에 특정 값을 하드코딩할 필요가 없게 해 준다. 대신 Node 서버가 시작할 때 해당 값들이 자동으로 입력된다. 이를 통해 개발 및 생산에서 다양한 값들을 사용할 수 있게 하고 전체 코드를 재배포하는 일 없이 생산에서 값을 편하게 변경할 수 있다. MongoDB Connection String이 좋은 예시인데 이 문자열은 Mongoose 클러스터에 연결할 수 있게 해준다. 현재 하드코딩 되어 있다. 만약 여기서 뭔가를 변경하려고 하면 코드 자체를 수정하고 재배포해야 한다. 이 코드를 누군가와 공유한다면 이 자격 증명을 알게 된다.
맨 밑의 코드가 시작할 포트를 설정하는데 개발에서는 3000을 사용하며 1000 범위를 넘기만 하면 어떤 숫자든지 사용할 수 있다. 그러나 Production의 경우 우리의 서버나 호스트 제공자(Hoting Provider)가 이 포트를 설정하게 두는 편이 좋은데 왜냐하면 이를 통해 서비스가 최종적으로 이 앱을 웹으로 공개하게 되며 모든 네트워크 설정을 구성하기 때문이다. 따라서 포트 번호를 우리가 조절하는 대신 서비스 제공자 측에서 하게 된다. 
환경 변수를 사용해 볼 또 다른 예시는 컨트롤러 폴더의 shop.js 파일의 Stripe API 키 등이 있다. 이건 생산 키로 대체해야 할 개발용 키이지만 Mongoose 데이터에서와 동일한 이유로 하드코딩한다는 건 그리 좋은 생각이 아니다. 

먼저 MONGODB_URL을 백틱을 사용해 템플릿 리터럴로 변경한다. 여전히 일반 문자열이지만 값을 인젝트할 수 있다. 이제 process 객체에서 환경 객체에 접근할 수 있다. 이것은 우리가 정의한 객체는 아니지만 Node App 전체에서 사용 가능하다. Node의 핵심 런타임 일부에 해당한다. 이 process 객체에는 env 속성이 있는데 이 Node process가 아는 모든 환경 변수를 포함한 객체다. 다양한 디폴트 환경 변수가 있지만 직접 설정할 수도 있다.

    const MONGODB_URI = `mongodb+srv://${process.env.MONGO_USER}:${process.env.MONGO_PASSWORD}@cluster0.bcol3h1.mongodb.net/${process.env.MONGO_DEFALUT_DATABASE}`;
- 이 전체 문자열도 해당 문자열이 규칙적으로 변하는지에 따라 전체를 변경할 수도 있고 내부의 값만 변경할 수도 있다. 
    app.listen(process.env.PORT || 3000);
- 포트 넘버는 정의되지 않으면 3000으로 한다. 이걸 관리해 주는 호스트 제공자는 자동으로 포트 넘버를 입력한다. 즉, 대부분의 경우 설정되는 대로 따라가며 로컬 개발의 경우 설정되지 않기 때문에 계속 3000을 사용할 것이다.
    const stripe = require('stripe')(process.env.STRIPE_KEY);
- 컨트롤러 폴더의 shop.js 파일에서 stripe 키도 바꾼다.

이제 Node 코드에 있는 이 환경 변수들을 읽어야한다. 어떻게 Node에 전달할까? Node 앱을 실행할 때 이루어진다. nodemon을 사용하면 구성 파일을 제공할 수 있다. 프로젝트의 루트 폴더에 nodemon.json 파일을 추가한다. 여기에 코드에서 읽으려고 한 모든 변수의 실제 값을 입력한다.  
nodemon.json =>
    {
        "env": {
            "MONGO_USER": "...",
            "MONGO_PASSWORD": "...",
            "MONGO_DEFALUT_DATABASE": "...",
            "STRIPE_KEY": "..."
        }
    }

이제 npm start로 서버를 시작하면 정상적으로 작동해야 한다.

항상 nodemon을 사용하진 않고 특히 이 앱을 배포할 때는 안 쓸 텐데 왜냐하면 어차피 코드를 변경하지 않으므로 매번 변경할 때마다 서버를 재시작하고 싶지 않기 때문이다. 따라서 새로운 start 스크립트를 package.json 파일에 추가한다.
package.json =>
    "scripts": {
        "start": "NODE_ENV=production ... node app.js",
        ...
        "start:dev": "nodemon app.js"
    },
- 이름은 아무거나 상관없다. 여기엔 nodemon을 사용하고 메인 start 스크립트에는 node를 사용하려 한다.
- 메인 start 스크립트에서는 nodemon.json 파일을 쓰지 않기 때문에 환경 변수를 전달하려면 다른 솔루션들이 있다. 또한 호스트 제공자를 사용한다면 호스트 제공자의 대시 보드에서 환경 변수를 설정할 수 있다. 일단 간단한 솔루션으로 설정하려는 키 값 쌍을 가져다가 start 스크립트 앞에 추가한다. MONGO_USER=max MONGO_PASSWORD=... 이런 식으로 입력한다. 띄어쓰기로 구분한다.

수동으로 설정할 수 있는 특별한 환경 변수 하나는 NODE_ENV 이다. 이건 기본으로 설정되지 않았음에도 특별한 환경 변수인데 Express.js가 환경 모드를 정의하기 위해 기본값으로 이걸 사용하기 때문이다. 그리고 이걸 production으로 설정하면 Express.js가 몇 가지를 변경하는데 예를 들면 출력하는 오류의 세부 사항을 줄이며 일반적으로는 배포를 위해 몇 가지를 최적화한다.  
app.js =>
    console.log(process.env.NODE_ENV);
서버를 재시작해보면 undefined가 출력되는데 이건 호스트 제공자들이 자동으로 설정한다. package.json에 위의 방법으로 직접 설정할 수도 있다.
===========================================================================================
452_Helmet으로 보안 응답 헤더 설정

Helmet이라는 제3자 패키지를 사용해 보안 헤더를 설정할 것이다. 최종적으로 이 패키지는 반환한 응답에 특정 헤더를 추가하고 모범 사례를 따른다.
    npm install --save helmet
다운로드하고 미들웨어로 포함하면 자동으로 모든 들어오는 요청에 대해 실행된다. 
    const helmet = require('helmet');
    ...
    app.use(helmet());
다른 미들웨어들이 모두 설정되는 위치에 작성하고 함수로 실행한다.

브라우저의 Network 탭을 보면 응답에 몇 개의 헤더가 설정되었는지 볼 수 있다. helmet을 설정하면 몇 개의 헤더가 추가된다. 
===========================================================================================
453_에셋 압축

    npm install --save compression
설치하고 app.js 파일에서 임포트한다. 그리고 helmet 미들웨어 다음에 추가하고 함수로 실행한다.
    const compression = require('compression');
    ...
    app.use(compression());

브라우저의 Network 탭에서 main.css, main.js 파일을 보면 에셋의 크기가 줄어든 것을 볼 수 있다. 코드를 다량 서비스해야 하는 앱이나 일반적으로 많은 파일을 제공하는 경우 고려할 만한 가치가 있다.
참고로 이미지 파일은 압축하지 않는데 왜냐하면 그럴 경우 로드하는데 시간이 더 오래 걸리기 때문이다.

대부분의 호스트 제공자들은 압축 지원이 일부 내장되어 있거나 최소한 이 압축 지원을 제공하여 쉽게 추가할 수 있도록 해준다. 따라서 즉시 에셋을 압축해 주니 직접 미들웨어를 사용할 일은 없을 것이다. 사실 만약 호스트 제공자 측에서 지원한다면 직접 압축하면 안 된다. 그러나 호스트 제공자가 지원하지 않거나 직접 서버를 구축하는 경우 추가하기에 좋은 미들웨어이다.
===========================================================================================
454_요청 로깅 설정

압축과 헤더 뿐만아니라 로그 기록도 중요하다. 이를 위해 패키지를 설치한다. 
    npm install --save morgan

    const morgan = require('morgan');
    ...
    const accessLogStream = fs.createWriteStream(
        path.join(__dirname, 'access.log'), 
        { flags: 'a' }
    );
    app.use(morgan('combined', { stream: accessLogStream }));
- 미들웨어를 설정하고 함수로 실행한다. 그리고 이 함수에 어떻게 로깅할지에 관한 정보를 전달한다. 첫 번째 매개변수만 설정하면 서버의 콘솔에 로그를 출력한다. 
- 일반적으로 파일에서 보는 게 좋으므로 두 번째 매개변수도 설정한다. 새로운 상수인 accessLogStream를 생성한다. 여기에 createWriteStream으로 쓰기 스트림을 생성하고 path_join으로 현재 폴더에서 보는 경로를 정의하고 access.log라는 파일을 생성하여 이 파일에 로그 기록을 작성할 수 있다. 그 뒤에 구성을 추가하는데 flags를 덧붙임을 뜻하는 'a'(append)로 설정하여 새 데이터가 기존 파일을 덮어쓰지 않고 해당 파일의 끝부분에 덧붙여서 계속해서 로그가 파일에 추가되도록 한다. 
- 위에서 설정한 스트림을 morgan에 전달한다.

morgan 함수에 매개변수로 다양한 설정을 전달하여 로그를 커스터마이징할 수 있다. 물론 대부분의 호스트 제공자에서 로깅 기능을 제공하므로 필요없을 수도 있지만 알아두자.
===========================================================================================
456_SSL 서버 설정

Using SSL/TLS

                                   binds key to Identity
       |-----------SSL Certificate <-------------------- Public Key
  Public Key            Decrypt
       |               |-------- Private Key 
    Client <========= Data =========> Server
                       ^
                       | SSL/TLS Encryption
                       | Eavesdropping
                       |
                    Attacker

TLS는 단순히 좀 더 새로운 버전이다. 둘 다 클라이언트에서 서버로 전송되는 데이터를 보호하는 것에 대한 요소이다. 왜냐하면 클라이언트와 서버 간 통신 시 일반적으로 데이터를 교환하게 된다. 공격자(Attacker), 즉 해당 데이터를 염탐하는 제3자가 기술적으로 존재할 수 있다. 이 공격자는 클라이언트에서 서버로 전송되는 데이터를 읽을 수 있어 신용카드 데이터 등과 관련해서는 문제가 될 수 있다. 따라서 데이터를 보호하기 위해 SSL/TLS 암호화를 사용한다.
암호화가 적용된 뒤에는 더 이상 염탐이 불가능한데 데이터가 이동 중에는 읽을 수 없게 되며 서버에서 해독되기 때문이다. 

암호화와 해독을 가능하게 하려면 공개, 비공개 키 쌍(Public Key, Private Key)을 다루게 된다. 양쪽 다 서버에 알려져 있다. 
공개 키는 이름처럼 보호할 요소가 아니다. 그러나 비공개 키는 서버에서만 알아야 하며 나중에 복호화에 사용된다. 공개 키는 암호화에 사용된다. 
SSL 인증서에서는 해당 공개 키를 서버의 신원에 결합하게 된다. 서버의 신원은 단순히 말하자면 도메인이나, 관리자의 이메일 주소 등으로 인증서를 생성할 때 설정하는 데이터이다. 따라서 SSL 인증서는 공개 키와 서버를 연결하고 이를 클라이언트와 브라우저로 전송되어 클라이언트 또한 공개 키를 인지하고 해당 키가 해당 서버에 속한다는 걸 알게 한다. 
일반적으로 인증서 권한을 사용하나 자신만의 SSL 인증서를 생성하는 것도 가능하다. 그러나 자신만의 키를 생성하는 경우 브라우저는 내부의 정보가 정확할 것이라고 신뢰하지 않는다. 그런 경우 '이 페이지는 SSL을 사용하지만 안전하지 않습니다. 정말 방문하시겠습니까?' 등의 경고 문구를 보게 된다. 따라서 Production에서는 브라우저가 신뢰하는 알려진 인증서 권한을 통해 제공되는 SSL 인증서를 사용하여 실제로 안전하고 신뢰할 수 있는 보호를 받는다. 
작동 방식은 항상 동일하다. 해당 인증서의 일부로 공개 키가 존재하고 인증서는 우리가 아닌 신뢰할 수 있는 기관에서 생성한다.
이 공개 키는 이후 클라이언트가 인증서를 통해 수신하게 된다. 그 뒤에 클라이언트는 서버로 전송하는 데이터를 암호화할 수 있으며 서버는 해당 비공개 키를 사용하여 데이터를 해독할 수 있다. 해당 비공개 키만이 해당 데이터를 해독할 수 있다. 

인증서를 생성하기 위해 openssl 이라는 명령어를 사용한다. Mac과 Linux에서는 기본값으로 제공되지만 Windows는 프로그램을 설치해야 한다.
    openssl req -nodes -new -x509 -keyout server.key -out server.cert
이를 통해 인증서에 포함되어 있는 비공개 키와 공개 키가 제공된다. 몇 가지 질문에 답해야 하는데 어차피 직접 생성한 인증서는 브라우저에서 허용하지 않으므로 적당히 입력한다. 다만 Common Name은 localhost로 설정한다. 그렇지 않으면 도메인으로 설정해야 해서 인증서가 작동하지 않는다. 따라서 직접 서명한 인증서를 앱을 배포할 서버에 사용하게 되고 이 앱을 example.com에서 호스트 한다면 여기도 example.com으로 설정해야 한다. 

설정을 마치면 server.cert, server.key 파일이 생성된다. cert는 인증서이고 key는 비공개 키다. 최종적으로 서버에 전송하는 건 인증서 부분이다. 비공개 키는 항상 서버에 남아있다.
app.js에서 https 서버를 가동하게 허용하는 https 모듈을 임포트한다. 지금까지는 app.listen을 통해 직간접적으로 http를 사용했지만 https를 사용할 것이다. 
app.js =>
    const https = require('https');
    ...
    const privateKey = fs.readFileSync('server.key');
    const certificate = fs.readFileSync('server.cert');
    ...
    https.createServer({key: privateKey, cert: certificate}, app).listen(process.env.PORT || 3000);
- node 파일 시스템 패키지를 사용하여 privateKey를 읽어온다. 이때 동기식을 사용하는데 파일을 읽을 때까지 코드 실행을 차단하게 되며 해당 파일을 읽기 전까지 서버 시작을 진행하지 않게 된다. 
- 이제 app.listen 대신 https를 사용하며 https 서버를 생성하기 위해 createServer를 입력한다. 여기엔 인수가 2개 필요하다. 첫 번째 인수는 서버를 구성하는데 우리의 비공개 키와 인증서를 지정해야 한다. 첫 번째 인수는 자바스크립트 객체로 두 가지를 설정한다. 두 번째 인수는 요청 핸들러이며 이 경우 Express 애플리케이션이 된다. 따라서 두 번째 인수는 우리의 app이 된다.
- 이후 해당 서버에서 듣는다(Listen). 

브라우저에서 기존처럼 localhost:3000으로 접속하면 기본값으로 http를 사용하여 실패한다. https://localhost:3000을 사용하면 직접 서명한 인증서를 받아주지 않아서 실패한다. 고급 옵션에서 무시하고 진행하기를 눌러 접속할 수 있다. 브라우저가 경고를 띄우지만 엄밀히 말해 SSL 보호를 사용하는 중이다.

하지만 이러한 설정은 호스트 제공자 측에서 설정할 텐데 왜냐하면 제공자가 서버를 보유하고 있고 호스트 제공자의 서버는 이후 SSL과 앱 간의 트래픽을 사용한다. 그리고 공개되어 있지 않기 때문에 그 사이에 서버가 http를 사용하며 호스트 제공자 프론트 서버가 이 논리를 구현할 것이다. 따라서 해당 코드를 직접 작성할 일은 없다.
그러므로 app.listen을 사용하는 기존 코드로 원상복구 한다. 호스트 제공자가 SSL을 관리하니 나중에 배포할 때 필요하기 때문이다. 