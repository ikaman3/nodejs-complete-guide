230_Sessions & Cookies

세션과 쿠키는 웹 개발에서 중요한 구조체 혹은 기술로, Node.js에서도 사용된다. 대게 둘은 함께 사용한다.

What's a Cookie?

      User
        |
Frontend(Views) ----------> Cookie
        |                     ^
Request | Include Cookies     |
        |                     | Set via Response Header
Server(Node App) -------------|

- 브라우저를 사용하는 사용자가 있고 노드 앱이 실행되는 서버가 있다.
- 이 앱에서는 사용자와 프론트엔드 간 상호 작용을 위해 ejs 템플릿 엔진으로 뷰를 렌더링한다. 다만 어떤 템플린 엔진이든 상관없다.
- 만약 뷰에 새 제품을 추가하는 양식이 있다면 Node 서버에 요청을 해야한다. 이 요청에 따라 브라우저에 일정 데이터를 저장해야 한다. 사용자가 로그인하면 로그인 정보를 어딘가에 저장해서 해당 사용자가 페이지를 새로 고침해서 새 요청이 보내져도 로그인 된 상태라는 정보를 가져야 한다. 따라서 요청에 대한 응답과 함께 쿠키를 보내는데 사용자가 로그인 데이터를 제풀하면 사용자를 리다이렉트할 뷰 등의 응답 외에도 쿠키를 포함한다. 여기서 쿠키는 사용자가 인증을 마쳤다는 정보를 저장하고 있다. 이런 정보를 브라우저 즉, 사용자가 실제로 상호 작용하는 프론트엔드 환경에 저장해서 이어지는 요청은 쿠키를 포함하며 쿠키에 저장된 데이터도 보내게 된다. 예를 들어 서버에 로그인 한 정보가 있을 것이다.
- 이처럼 쿠키는 클라이언트 측에 저장된다.
===========================================================================================
234_요청 기반 로그인 솔루션 추가

로그인 버튼을 누르면 login-form에 저장한 대로 벡엔드에 로그인 요청을 보낸다. /login 으로 POST 요청을 보내게 될 것이다.
이제 사용자가 인증되었다는 정보를 저장하고 싶다면 auth.js 컨트롤러의 사용자를 로그인하는 postLogin에 해당 정보를 요청 객체 isLoggedIn에 저장한다. 
controllers/auth => postLogin
    req.isLoggedIn = true;

그리고 view에서는 isAuthenticated 변수를 조건문으로 확인하여 로그인된 사용자에게만 네비게이션이 모두 보이도록 한다.
이때 인증은 모든 페이지의 일환이므로 모든 render 호출에 사용자 인증 여부를 전달해야 한다. 
contollers/admin => getProducts
    isAuthenticated: req.isLoggedIn
- 로그인을 하면 true로 설정되는 isLoggedIn 요청에 접근해 isAuthenticated에 저장한다. 
- 앱의 모든 render 호출에 같은 작업을 해야한다.

하지만 로그인을 해도 두 필드가 보이지 않는다. isLoggedIn에 정보를 저장하고 있어도 Login 버튼을 클릭하면 요청에 저장되고 이 정보를 다른 라우트에 대한 요청에 사용해 내비게이션에 쓰이는 프론트엔드 필드인 isAuthenticated에 전달한다. navigation.ejs를 보면 isAuthenticated를 render 함수마다 프론트엔드로 전달하고 있다.

여기서 문제는 요청에 isLoggedIn 정보를 업데이트해도 응답을 보낼 때 리다이렉션을 통해 응답을 보내므로 해당 요청이 끝나게 된다는 것이다. 요청을 받고 그에 대한 응답을 보내면 그대로 끝이다. 데이터가 더 이상 존재하지 않는다.
이렇게 요청이 보낸 후 혹은 응답을 보낸 후 데이터가 손실되기 때문에 다른 페이지를 방문하면, 예를 들어 로그인 후 리다이렉트 되어 getIndex 액션에 도달하는데 이때 shop/index를 렌더링하는 것은 새로운 요청이다. 
- 리다이렉트 되면 새로운 요청을 만든다는 것을 이해하라. 완전히 다른 요청을 다루는 것이다. 
- 또한, 앱에 수많은 사용자가 생길 것이고 많은 사용자의 요청 간 연관되지 않는 것이 맞다. 보여주면 안 되는 데이터까지 보여줄 수도 있기 때문이다. 

따라서 요청이 한 사용자로부터 즉, 같은 IP 주소로부터 비롯되었다 해도 각 요청은 따로 처리된다. 사용자가 더 큰 문맥과 같은 것을 보지 못하도록 의도적으로 구축되었다. isLoggedIn에 저장된 데이터는 같은 요청을 다루는 동안만 유효하다. app.js 에서 사용자를 검색할 때 요청에 저장한 것도 그 때문이다. 그에 따라 모든 액션 컨트롤러에서 req.user를 계속 사용할 수 있었다. 예를 들어 이 미들웨어 함수(방금 설명한 사용자를 검색하여 요청에 저장하는 app.use())는 라우트가 처리하기 전에 들어오는 모든 요청에 실행된다. req.user에 저장한 데이터를 컨트롤러의 라우트 핸들러 안에서 같은 요청 주기 동안 사용할 수 있는 것이다. 
하지만 주기의 끝에서 응답을 보내기 직전에 요청을 바꾸면 데이터를 쓸 수 없다. 그러므로 로그인 정보를 요청에 저장하면 안된다는 것을 배웠다.
===========================================================================================
235_쿠키 설정하기

위와 같은 문제를 해결하기 위해 다른 대안 중 하나로는 전역 변수가 있다. 다른 파일에 저장한 전역 변수를 불러오기 해서 바꾸면 되는데, 전역 변수는 요청 주기와 관계없이 계속 사용할 수 있다.
그러나 이 같은 전역 변수는 모든 요청 간 공유되기 때문에 사용자 같에도 공유된다는 뜻이다.

이제 쿠키가 유용하게 쓰인다. 쿠키를 이용하면 특정 사용자의 브라우저에 데이터를 저장해서 데이터가 해당 사용자에 맞춤화되어 다른 사용자에 영향을 미치지 않는다. 또 쿠키는 요청과 함께 보내지면서 사용자가 이미 인증되었다고 알려준다.

일단 postLogin에서 리다이렉트하기 전에 쿠키를 설정한다.
req.setHeader('Set-cookie', 'loggedIn=true')
- 요청에 헤더를 설정한다. 
- 우선 헤더의 이름을 Set-Cookie로 설정한다. Set-Cookie는 쿠키를 설정하는 예약명이다.
- 다음은 헤더의 값이다. 헤더 값의 가장 간단한 형식은 Key-Value 쌍이며 원하는 이름과 값을 지정한다.  

이제 앱에서 로그인 버튼을 누르고 개발자 도구를 열어 Application-Cookies 탭을 보면 loggedIn 쿠키가 존재한다. 이제 쿠키가 설정되었을 뿐만 아니라 요청을 보낼 때마다 브라우저가 디폴트로 서버에 쿠키를 보낸다. 
- Products 메뉴를 누르고 Network 탭을 보면 products 페이지로 보낸 요청의 Headers 탭에 loggedIn 쿠키가 보내진 것을 알 수 있다.

그리고 getLogin 컨트롤러에서 요청으로 들어온 모든 쿠키를 볼 수 있다.
req.get('Cookie').split(';')[0].split('=')[1] === 'true';
- split 메서드로 원하는 쿠키의 값만 추출한다.

그러나 한 가지 큰 단점이 존재한다.
===========================================================================================
236_쿠키 조작하기

지금의 접근법에는 결함이 존재한다. 일단 개발자 도구를 통해 쿠키에 쉽게 접근할 수 있고 변경도 쉬워서 true로 변경하면 로그인이 되어있다. 따라서 지금 문제는 브라우저 내부에서 조작이 가능한 것인데 쿠키 값을 약간 조작하여 로그인할 수 있도록 사용자들에게 허용해 줘서는 안된다.
- 쿠키가 일반적으로 요청 간 데이터를 저장함에 있어 유용하지만 모든 시나리오에서 최상의 접근은 아니므로 이런 상황에서 세션의 도움을 받을 수 있다. 
===========================================================================================
237_쿠키 구성하기

쿠키는 조작할 수 있기에 민감한 데이터를 저장하는 건 바람직하지 않지만 사용자 추적에 자주 사용된다. 쿠키는 본인의 페이지에만 관련될 필요가 없다. 다른 페이지로 전달할 수 있으며 이는 실제 이미지가 없는 이미지 URL인 페이지에 트래킹 픽셀이 있는 위치 추적에 흔히 활용되는 도구다. 그러나 해당 이미지는 예를 들어 구글 서버에 존재할 수도 있는데 해당 페이지에 존재하는 쿠키에 함께 전송됨으로써 어느 페이지에 있는지 확인하고 웹사이트에 접속하지 않아도 구글이 이동 경로를 추적할 수 있게 된다. 그러니 사용자를 추적하길 원한다면 자주 사용되는 방법으로 쿠키를 구성할 수도 있다.

쿠키에는 더 많은 설정을 할 수 있다. 다수의 쿠키와 다수의 키-값 쌍을 추가하는 것도 가능하다.

req.setHeader('Set-cookie', 'loggedIn=true; Max-Age=10')
- Expires/Max-Age: 쿠키 만료일 설정. HTTP 날짜 형식을 준수해야 함. 이걸 설정하지 않으면 브라우저를 닫는 순간 만료된다. Expires 대신 Max-Age라고 입력해도 된다. 이때 단위는 초단위이다(Max-Age=10 : 10초)
- Domain: 쿠키를 전달하는 Domain을 추가한다.
- Secure: 등호를 제외하고 Secure만 추가한다. 이 경우 쿠키는 HTTPS를 통해 페이지가 제공될 경우에만 설정된다.
- HttpOnly: 등호를 제외하고 HttpOnly만 추가한다. 쿠키를 HTTP 전용으로 설정한다. 개발자 도구로 확인하면 HTTP 열에 체크 표시가 되어 있다. 즉, 클라이언트 측 자바스크립트, 브라우저에서 구동 중인 스크립트를 통해 쿠키 값에 더 이상 접근할 수 없음을 의미한다. 이건 중요한 보안 매커니즘이 될 수 있는데 크로스 사이트 스크립팅 공격으로 부터 보호할 수 있다. 누군가 악성코드를 심어놓았을 수 있는 클라이언트 측 자바스크립트가 쿠키를 읽을 수 없고 이 특성은 추후 인증 부문에서 쿠키가 민감한 정보는 저장하지 않지만 사용자 인증에 중요한 정보를 저장할 때 중요하게 작용한다. 따라서 부가적인 보안 층이 되어 서버로 전송되는 모든 요청에 쿠키가 계속 포함된다. 하지만 브라우저 자바스크립트 코드 내부에서는 쿠키 값을 읽을 수 없다. 
===========================================================================================
238_What's a Session?

      User
        |
Frontend(Views) ----------> Cookie
        |                     ^   Associated with user/client 
Request |                     |   via cookie
        |                     | 
Server(Node App) --------> Session 
        |                     | 
    Database -----------------| Session Storage

이전과 동일하게 사용자가 프론트엔드(뷰)를 사용하고 뷰는 노드 앱 코드가 존재하는 서버와 상호작용하며 요청을 전송하고 로그인을 전송한다고 가정한다. 
사용자가 인증되었다는 정보를 좋지 못한 장소인 프론트엔드에 저장하는 대신 세션이라고 하는 백엔드에 저장한다. 세션은 요청도 아니고 Express 앱의 어느 변수에 저장하는 것도 아니다. 동일한 사용자 전용이기 때문에 다른 사용자가 데이터를 읽을 수 없고 서버에게 인증되었다고 거짓말할 수도 없다. 
이를 위해 정보를 서버에 저장해야 한다. 메모리에 저장하는 것으로 시작하며 이건 변수에 저장하는 것과 유사하다. 최종적으로 세션 저장소인 DB로 이동할 것이며 중요한 정보가 하나 필요하다. 
클라이언트는 서버에게 자신이 소속된 세션을 알려야 하는데 최종적으로 세션은 단순히 메모리나 DB에 저장된 입력값에 불과하기 때문이다. 이 정보는 IP 주소를 비롯한 기타 정보와 대조하지 않는데 유지하기도 어렵고 위조도 가능하기 때문이다. 대신 세션의 ID를 저장하는 쿠키를 활용한다. 물론 이것도 변경할 수 있고 다른 ID도 사용 가능하다. 그러나 이것과 같은 효과가 없는 이유는 저장하는 값이 사실 ID가 아니라 특정 알고리즘으로 해시 처리된 ID이므로 사용자가 변조하거나 다른 ID를 생성하지 않았음의 여부는 서버 측에서만 확인 가능하기 때문이다. 즉, 저장된 쿠키 값이 DB의 특정 ID와 관련되어 있다는 것을 서버 측에서만 확인할 수 있도록 암호화된 방식으로 ID를 저장하기 때문에, 이는 보안성이 높은 방법으로 쿠키에 안전한 값이 저장된다. 이를 변경할 수는 있지만 다른 세션으로는 간주할 수 없다. 세션을 일치시키면 해당 세션은 기밀 데이터를 포함하고 이를 브라우저 내부에서는 변경할 수 없다는 것이 핵심 개념이다. 
즉 세션은 서버 측, 쿠키는 클라이언트 측에 저장된다.
===========================================================================================
239_세션 미들웨어 초기화

세션을 구현하려면 제3자 패키지가 필요하다. 공식 Express.js 모음의 일부지만 Express.js에 직접 포함되진 않았다.
npm install --save express-session

우선 app.js에서 일찍 세션을 초기화한다. 
app.js =>
    const session = require('express-session');
- 설치 후 다른 미들웨어들과 함께 설정할 수 있다.
    app.use(
        session({
            secret: 'my secret',
            resave: false,
            saveUninitialized: false,
        }));
- app.use에 session을 전달하고 이걸 함수로 실행한다. 그리고 이 함수에 세션 설정을 구성하는 자바스크립트 객체를 전달한다. 
- secret: ID를 비밀리에 쿠키에 저장하는 해시를 등록할 때 사용한다. 아무 텍스트나 입력해도 되며 일반적으로 긴 문자열을 입력한다. 
- resave: false로 설정한다. 세션이 완료되는 모든 요청마다 즉, 전송되는 모든 응답마다 저장되는 것이 아니라 세션이 변경되었을 때만 저장되어 성능 개선에 기여한다.
- saveUninitialized: 저장할 필요가 없는 요청의 경우 변경된 내용이 없어서 아무 세션도 저장되지 않도록 한다.
- cookie: 세션 쿠키를 구성한다. {} 안에 설정 값을 키-값 형태로 입력한다. 날짜를 설정하여 maxAge를 부여하거나 expires 키도 추가할 수 있다. 이렇게 쿠키를 구성할 수도 있고 디폴트 설정으로 진행해도 좋다.
===========================================================================================
240_세션 미들웨어 사용하기

auth 컨트롤러의 로그인에서 쿠키 대신 요청과 세션 객체로 접근한다. 
- 이 세션 객체는 세션 미들웨어에서 추가된 부분이다.
req.session.isLoggedIn = true;

이제 로그인 버튼을 누르고 개발자 도구로 보면 세션 ID를 뜻하는 connect.sid 쿠키가 있다. value에는 암호화된 값이 있고 기본값으로는 세션 쿠키이므로 브라우저를 닫으면 만료된다. 이 세션 쿠키는 이곳의 사용자, 이 웹사이트의 실행 인스턴스 즉, 검색하고 있는 장소를 식별한다. 이 쿠키가 우리를 서버와 세션에 식별해주는 것이다. 
getLogin 컨트롤러에서 req.session.isLoggedIn을 출력해보면 true가 출력된다. 세션 내부에 isLoggedIn이 저장되었기 때문이다. 
- 다른 페이지로 갔다가 로그인으로 돌아오면 여전히 true가 출력된다.
이걸 서버 측 세션에 저장하고 기본값으로 메모리에 저장한다. 그리고 해당하는 쿠키가 있기 때문에 이 브라우저에 대한 세션이 식별된다. 
- 이때 다른 브라우저 또는 다른 머신으로 접속하면 undefined가 나온다. 이 사용자는 설정된 쿠키가 없으며 서버에 활성화된 세션도 없기 때문이다.

사용자를 식별하기 위해 여전히 쿠키가 필요하지만 민감한 정보는 서버에 저장된다. 변경할 수 없고 이러한 특성은 인증에 있어서 매우 중요한 요소다. 해당 내용은 웹상에서 사용자를 인증하는 핵심 메커니즘이다.
===========================================================================================
241_MongoDB로 세션 저장하기

지금 세션은 메모리에 저장되는데 메모리는 무한한 자원이 아니다. 따라서 개발 시에는 몰라도 실제 서버의 경우 많은 사용자가 있는 상황에서 모든 정보를 메모리에 저장하면 빠르게 오버플로우된다. 따라서 DB를 이용하는 것이 바람직하다.

npm install --save connect-mongodb-session

우선 app.js에서 세션을 초기화하고 구성하고 있는데 store도 구성해야 한다. 
app.js =>
    const MongoDBStore = require('connect-mongodb-session')(session);
- 여기에서 실행할 수 있는 함수가 제공되고 세션으로 전달한다. express-session에서 임포트하는 세션 객체는 함수로 전달되며 require('connect-mongodb-session')을 통해 산출되며 해당 함수 호출의 결과는 MongoDBStore에 저장된다. 그 결과는 생성자 함수이다. 
    const store = new MongoDBStore({
        uri: MONGODB_URI,
        collection: 'sessions'
    });
- 이후 생성자로서 MongoDBStore를 실행한다. 이 생성자에 몇 가지 옵션을 전달한다. 
- uri: Connection 문자열을 필요로 한다. 어느 DB 서버에 저장할 지 파악하기 때문이다. 별개의 DB를 사용할 수도 있지만 동일한 DB를 사용해도 무방하다.
- collection: 컬렉션을 정의한다. 세션을 정의하는 컬렉션은 반드시 정의해야 한다. 
- MongoDB에 의해 언제 만료되고 자동으로 정리되는지와 같은 추가 정보도 설정할 수 있다.

이제 스토어 설정이 끝났으니 세션 스토어로써 사용할 수 있고 사용을 위해 아래쪽에 세션을 초기화했던 부분에서 store 옵션을 추가한다.
    app.use(session({
            secret: 'my secret',
            ...
            store: store
        }));
- store: 초기화된 MongoDBStore를 저장할 store다. 이를 통해 세션 데이터가 해당 장소에 저장된다. 

로그인 버튼을 클릭하면 새로운 세션, 세션 쿠키가 생성되고 세션은 MongoDB에 저장된다. 

세션은 주로 인증 관리에 탁월한 수단이지만 장바구니 같은 다른 것도 저장할 수 있다. 데이터베이스에 저장하는 것도 좋지만 세션에 저장함으로써 간접적으로 세션 데이터베이스 컬렉션에 저장할 수 있다. 
따라서 일반적으로 세션은 응답을 매번 전달할 때마다 잃어버리고 싶지 않으며 다른 사용자에게 보여서는 안되는 사용자 관련 데이터를 대상으로 사용한다.
===========================================================================================
243_쿠키 삭제

쿠키만을 삭제하는 것은 바람직하지 않다. 예를 들어 현재 Compass에서 sessions 컬렉션을 보면 쿠키만 지우는 경우 매번 새로운 세션이 생성되어 있을 것이다. 이를 더 깔끔하게 하는 방법은 세션 미들웨어가 제공하는 메서드를 사용하는 것이다.

views 폴더로 가서 navigation 파일의 로그인 버튼 옆에 로그아웃 버튼을 추가한다. 이걸 클릭하면 보유 중인 모든 세션을 삭제할 것이므로 새로운 라우트를 등록한다.
- auth 라우트로 가서 새로운 POST 라우트를 추가한다. 

그리고 auth 컨트롤러 파일의 postLogout 컨트롤러에서 세션 객체로 접근하여 destroy를 호출한다.
req.session.destroy((err) => {
   console.log(err);
   res.redirect('/');
});
- 세션 파괴가 끝난 뒤 호출될 함수를 전달된 내부에서 가져오는데 이 시점에서 req.session은 파괴했으므로 사용할 수 없다. 

참고로 세션은 파괴되었지만 세션 쿠키는 아직 존재하는데 대응하는 세션이 없기 때문에 문제는 없다. 어떠한 기능도 수행하지 못할 것이고, 다시 로그인하면 갱신되며 세션 쿠키를 덮어쓰게 된다. 브라우저를 닫으면 이것도 삭제되는데 지속 쿠키가 아니기 때문이다. 
===========================================================================================
245_장바구니에 추가 항목 만들기

지금 코드에서 addToCart 함수를 실행하는 데 실패했다. user 객체에서 사용할 수 있는 함수를 실행하지 못한 이유는 무었인가?
이유는 기존에 다른 설정에서 항상 요청에 user를 저장했고 이건 요청 액션마다 이루어졌다. 또한 app.js 미들웨어에서 각각의 요청마다 사용자를 가져왔었다. 따라서 DB에서 사용자를 가져오면 Mongoose가 자동으로 전체 객체를 전달했었다. DB의 데이터뿐만 아니라 모든 메서드를 포함한 전체 모델을 전달하였다. 그리고 우리는 그 사용자 모델을 요청에 저장했지만 세션에서는 조금 다르다.

세션의 경우 모든 요청마다 이걸 가져오지 않는다. 대신 로그인을 통해 사용자를 세션에 저장한다. user는 DB에 저장한다. 이제 이건 단순한 데이터다. 매번 새로운 요청마다 세션 미들웨어는 Mongoose의 도움을 토대로 이동하여 사용자를 가져오지 않는다. 대신 MongoDB에서 세션 데이터를 가져온다. 하지만 이를 위해 MongoDBStore를 이용하며 해당 기능은 Mongoose 모델을 모른다. 따라서 세션 DB로부터 데이터를 가져올 때 Mongoose가 제공한 모든 메서드가 반영된 객체를 가져오지 못하고 데이터만 가져온다. 

그럼 무엇을 해야할까? 세션을 초기화한 뒤에, 요청에 사용자를 저장하기 위해 사용했던 일반 미들웨어를 추가한다. 그리고 postLogin 라우트에서 주어진 ID에 대한 사용자를 가져오는 논리를 가져와서 미들웨어로 옮긴다. 
    app.use((req, res, next) => {
        if (!req.session.user) {
            return next();
        }
        User.findById(req.session.user._id)
            .then(user => {
                req.user = user;
                next();
            })
            .catch(err => console.log(err));
    });
- 여기서 세션에 아무것도 저장하지 않는다. 세션은 이미 자동으로 관리되고 있다. 들어오는 모든 요청의 경우 미들웨어를 등록한다. 이후 미들웨어는 세션 쿠키를 탐색하고 만약 찾으면 DB에서 적합한 세션을 찾아 데이터를 로드한다. 이 미들웨어에 도달한 즈음엔 세션 데이터가 로드되어 있는 것이다. 즉, 실제 사용자를 로드하고 Mongoose 사용자 모델을 생성할 때 해당 세션 데이터만을 사용하는 것이다. DB에 접근하지 않고 이 요청에 대해서만 사용자를 설정한다. 
- 세션에 저장된 데이터를 기반으로 사용자를 생성할 것인데 요청들 간에 존재하는 데이터이며 사용자를 생성해서 req.user에 저장한다. 이는 해당 요청에 대해서만 존재하겠지만 세션의 데이터를 받아 작동한다. 따라서 요청들 간에도 살아남는다고 할 수 있다. 이렇게 하는 이유는 작업을 진행할 Mongoose 모델이 필요하고 MongoDB의 세션 저장소에 저장한 데이터는 Mongoose의 메서드가 없이 순수한 데이터만 가져오기 때문이다. 
- 이 미들웨어의 논리: 세션에 저장된 user에서 _id를 읽고 Mongoose가 제공하는 user 모델의 도움을 받아 DB에서 해당 사용자를 찾는다. 그리고 then 블록에 Mongoose 모델인 user가 돌아오는데 이건 req.user에 저장하며 이 방법을 통해 작업 가능한 Mongoose 모델의 존재를 확인하고 Mongoose 메서드를 다시 사용할 수 있다. 

이제 admin.js, shop.js의 req.session.user를 req.user로 교체한다. app.js에서 req.user에 Mongoose 모델인 user를 저장했기 때문이다. 

중요한 점은 여기서 Request에 저장했다고 해서 user 모델이 해당 요청에만 존재한다는 뜻이 아니다. Mongoose 모델 객체는 해당하지만 세션에 저장된 데이터 즉, 요청들 간 존재하는 데이터로 구동하게 된다. 
===========================================================================================
246_작은 개선 사항

로그인을 해도 뷰가 업데이트되지 않는 상황이 존재할 수 있다. auth.js의 postLogin에 session을 설정하고 redirect로 응답을 보낼 때 세션 미들웨어가 미리 세션을 만들어 MongoDB에 작성하는데 MongoDB 세션 저장소가 쿠키를 설정하기 때문이다. 문제는 DB에 데이터를 작성하는건 몇 ms 단위로 시간이 소요되는데 redirect는 독립적으로 실행되므로 너무 일찍 일어날 수도 있다. 따라서 세션이 설정된 것을 확실히 하고 넘어가도록 하기 위해 
req.session.save() 메서드를 호출한다. 보통은 호출하지 않아도 되지만 작업을 이어가기 전에 세션 생성을 확실히 해야하는 경우 세션을 저장한 후에 호출될 함수를 전달하면 된다.

    req.session.save(err => {
        console.log(err);
        res.redirect('/');
    });

요약하자면 보통은 호출할 필요 없는데 리다이렉트 같이 세션 설정을 보장해야 할 때는 꼭 호출하도록 하자. 세션이 저장되는 것과 별개로 redirect가 실행되기 때문에 서버와 DB에 세션이 업데이트되기 전에 redirect가 실행되어 새 페이지를 렌더링 할 수도 있다는 점을 유의하자.
===========================================================================================
247_Session Cookie & Permanent Cookie

Session Cookie
- 브라우저를 닫으면 디폴트로 만료되는 쿠키를 세션 쿠키라고 부른다. 세션을 식별하기 위해 사용되는 쿠키가 아니다. 세션 쿠키는 현재 브라우저의 해당 페이지에 있는 동안 유효하기 때문에 세션 쿠키라고 불린다. 

Permanent Cookie
- 만료 날짜나 쿠키가 무효화되는 수명을 설정하는 쿠키는 지속 쿠키라고 부른다. 영원한 것은 아니고 브라우저를 닫아도 사라지지 않는다는 의미다. 유효기간이 만료되어야만 삭제된다. 

쿠키는 세션과 함께 사용되는 경우가 많지만 세션에만 국한되어 있지는 않다. 트래킹 쿠키가 그 예다. 

세션은 쿠키를 식별해야 하는데 브라우저를 닫으면 사라지는 세션 쿠키와 다른 개념이다. 세션 쿠키나 지속 쿠키나 상관없이 사용할 수 있다. 여기서 얘기하는 개념은 단지 세션을 식별하는 데 사용되는 쿠키가 있으며 만약 서버에 데이터가 있으면 어떤 사용자에 속한 데이터인지 알 수 없기 때문에 이런 쿠키가 필요한 것이다.