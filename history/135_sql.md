135_소개

여태까지 프로그램에 변수와 데이터를 저장하는데 메모리를 사용했으며 요청 간에 저장된 데이터가 공유되었다. 혹은 파일에 저장하기도 했는데 데이터가 많아질수록 파일 접근이 느려지기 때문에 최적의 방법은 아니다. 그 대신 데이터 저장, 검색에 최적화된 데이터베이스를 사용한다.

- SQL과 NoSQL의 차이점에 대해 알아볼것이다.
- Node.js 앱에서 SQL을 사용하는 방법을 배울 것이다.
======================================================================================================================================
136_SQL vs NoSQL

우리의 목표는 항상 데이터를 저장하고 쉽게 가용 혹은 접근할 수 있게 하여 코드 측면뿐만 아니라 데이터 접근도 용이하게 하는 것이다. 물론 효율적이고 빨라야 한다. 이것이 데이터베이스를 사용하는 이유다. 내부 데이터가 커질수록 파일 접근보다 빠르고, 정보 한 조각을 찾기위해 전체 파일을 읽을 필요가 없다.

SQL: e.g. MySQL
- SQL DB는 테이블이라는 요소를 통해 사고하는데 즉, 사용자, 제품, 주문 테이블이 있다고 가정하자. 각각의 테이블에는 행과 열이 있다. 열은 ID, 제목, 이름 등 영역을 구성하고 레코드(행)라고 부르는 이 영역에 데이터를 채운다.
- 다른 테이블을 연결할 수 있다. 주문 테이블은 사용자와 제품 테이블의 관계로 이루어진다.
- Data Schema: 각각의 테이블마다 내부 데이터의 형태, 보유한 영역과 각각에 저장되는 데이터의 종류를 분명하게 정의한 것. 모든 데이터는 해당 테이블의 스키마와 일치해야 한다.
- Data Relations: 일대일, 일대다, 다대다 라는 세가지 중요한 상관관계를 이룬다. 즉, 테이블들이 연결되어 있다는 것이 중요한 특성이다.
- SQL Queries: 쿼리는 데이터베이스와 상호작용할 때 사용하는 언어다. SQL 언어는 몇 가지 키워드로 구성되고 이 키워드와 연결하는 몇 가지 매개변수 또는 데이터를 삽입한다. 이것이 SQL의 작동 방식이다.

NoSQL: e.g. MongoDB
- 간단히 말해 SQL의 방식을 따르지 않았다는 의미이다. 이것 또한 다양한 쿼리 언어를 사용하지만 스키마와 상관관계 대신 NoSQL은 다른 부분이나 다른 장점이 있다.
- NoSQL도 데이터베이스가 있으며 Shop 등의 이름을 지정할 수 있는데 NoSQL에서 테이블은 집합(Collection)이라고 부른다. 집합에 기록은 존재하지 않지만 문서는 존재한다. 자바스크립트의 객체와 닮은 이 문서는 JSON 포맷이다.
NoSQL에는 엄격한 스키마가 없다(Schemaless) 즉, 같은 집단에 각각 다른 구조를 지닌 다수의 문서를 저장할 수 있다. 물론 비슷한 구조로 통일하려고 하겠지만 몇몇 영역이 다른 문서도 저장할 수 있다.
- NoSQL에는 실제 상관관계가 존재하지 않는다. 대신 데이터를 복제한다. 즉, 주문 집합이 있다면 중첩된 문서인 사용자가 사용자 집합에 더 자세하게 분리된 문서로 저장된다. id, 또는 상관관계로 연결하지 않는다. 단순히 데이터를 복제하는데 정확히는 이 명령 집합에 필요한 데이터를 복제한다. 물론 데이터가 변경되면 여러 장소에서 업데이트를 해야함을 의미한다.
만약 이 장소들이 전부 최신 업데이트가 필요해도 큰 문제는 없다. 왜냐하면 데이터를 받았을 때 다수의 테이블을 하나로 합칠 필요가 없다는 이점을 제공해 매우 길고 어려운 코드가 되어 성능에 영향을 미치는 일은 없다.
- 즉, 일반적으로 NoSQL 특징은 강한 데이터 스키마가 없으며 동일한 집합에 혼합된 데이터가 존재할 수 있으며 어떤 구조도 강요되지 않고 일반적인 데이터 상관관계도 없다. 일정 부분 문서를 연관 지을 수는 있다. 
======================================================================================================================================
138_SQL, NoSQL 비교하기 

Horizontal(수평) vs Vertical Scaling(수직) Scaling(스케일링)
- 사용자가 늘어나고 데이터가 쌓여가는 앱의 유지를 위해서는 데이터베이스를 확장해야 한다. 
- 수평 스케일링은 서버를 더 추가한다. 장점은 무한으로 진행할 수 있다. 클라우드 제공업체든 자체 데이터 서버든 새로 서버를 구매하여 데이터베이스에 연결하고 서버에 데이터를 분산하면 된다. 동시에 쿼리를 모든 서버에 실행하고 지능적으로 통합하는 절차도 필요하는 것을 의미한다. 따라서 쉽지는 않지만 스케일링에 좋은 방법이다.
- 수직 스케일링은 존재하는 서버에 CPU나 메모리 등을 추가하여 더 강화하는 것을 뜻한다.
- 특히 클라우드 제공업체의 경우 이 방식이 일반적으로 용이하여 목록에서 다른 옵션을 고르고 돈을 더 내면 끝이다. 문제는 한계가 존재한다. 단일 머신에 무한정 CPU 출력을 집어넣을 수는 없다. 

SQL vs NoSQL
- SQL이 작동하는 방식으로 인해 수평 스케일링이 매우 어렵거나 심지어 불가능한 경우도 있다. 물론 서버를 추가하는 건 가능하지만 전부 하나의 공유된 데이터 클라우드, 하나의 공유된 데이터베이스에서 구동하는 건 꽤 어렵다. 수직 스케일링은 쉽게 할 수 있다.
- NoSQL은 수평 스케일링이 더 쉽다. 작동 원리를 알아야 하지만 클라우드 제공업체들이 대신해 주는 부분이다. 일반적으로 연결의 수가 적은 작동 방식으로 인해 가능한 일이다. 따라서 방대한 읽기 및 쓰기 요청에 대해 탁월한 성능을 얻게 되고 NoSQL은 처리량이 매우 많은 앱에서 고성능을 발휘한다. 물론 수직 스케일링도 가능하다.
- 여기까지만 보면 SQL이 뒤떨어지는 것처럼 보이지만 실제로는 저장하는 데이터의 종류에 따라 항상 달라진다. 상관관계가 정말 중요한 곳에 저장하고 테이블 전반에 걸쳐 분할한다던가 강력한 스키마를 보유하길 원한다면 SQL이 적합하다. 그리고 모든 데이터를 초당 몇 차례씩 액세스하지도 않는다. 데이터를 관리하는 부분이 앱에 존재할 수 있다. 따라서 자주 변경되지 않는 사용자 데이터라면 SQL이 적합하다. 
- 주문이나 장바구니 같이 앱에서 자주 변경되는 부분이라면 NoSQL이 적합하다. 이 경우 상관관계가 별로 중요하지 않는 이유는 장바구니나 주문에 해당하는 모든 정보는 단일 문서에 항상 배치할 수 있기 떄문이다. 일부 사용자 데이터를 저장한다 해도 사용자가 사진을 변경했다는 이유만으로 그 문서를 건드릴 필요는 없다. 어차피 주문과 함께 그 정보를 저장하진 않을 것이기 때문이다.
======================================================================================================================================
140_데이터베이스 연결

mysql, mysql workbench를 컴퓨터에 설치한다.
npm install --save mysql2 

sql 데이터베이스와 연결하는 방법은 두 가지가 있다. 하나는 연결 하나를 설정한 다음 쿼리를 실행하기 위해 이를 사용하는데 쿼리를 완료한 다음에는 항상 연결을 닫아야 한다. 새로운 쿼리마다 연결을 생성하기 위해 코드를 재실행해야 한다. 이것은 비효율적이다. 다른 하나는 커넥션 풀 이라는 개념이 있다.

util/database.js =>
    const mysql = require('mysql2');

    const pool = mysql.createPool({
        host: 'localhost',
        user: '사용자이름',
        database: '생성한 데이터베이스 이름',
        password: '비밀번호'
    });

    module.exports = pool.promise();
- const pool = mysql.createPool: 다중 연결을 관리하는 이 풀에서 새로운 연결을 받아오면 각 쿼리마다 개별적으로 연결이 가능하므로 다수의 쿼리를 동시에 실행할 수 있다. 쿼리가 완료되면 연결을 다시 풀로 돌려주고 새 쿼리에 사용할 수 있다. 풀은 앱을 종료할 때 완료된다.
- module.exports = pool.promise(): promise를 호출한다. 커넥션을 작업할 때 promise를 사용함으로써 콜백 대신 비동기적 태스크, 비동기적 데이터를 다룰 수 있다. 다수의 중첩 콜백 대신 promise 체인을 사용하여 더 효율적인 코딩이 가능하다.
이제 database.js 파일을 import 하여 이 풀과 커넥션에 접근할 수 있다. 

    const db = require('./util/database');
    db.execute('SELECT * FROM products')
    .then(() => {})
    .catch(err => {});
쿼리 실행방법에는 query, execute가 있는데 후자가 좀 더 안전하므로 이걸 사용한다.
- then, catch: 풀을 내보낼 때 promise를 사용하는 경우 제공되는 기능. Promise는 then, catch 메서드가 있다.
이 함수들은 execute 호출 결과에 연결할 수 있다. 따라서 돌려주는 값을 토대로 실행할 것이고 이걸 promise 라고 한다.

Promise: 기본 JavaScript 객체로 브라우저에서 자바스크립트를 이용해 비동기적 코드를 작업할 수도 있다. MySQL 패키징에서도 사용할 수 있는 콜백 대신 프로미스는 좀 더 체계적인 코드 작성을 할 수 있도록 한다. 왜냐하면 중첩된 익명 함수를 두 번째 인수로 두는 대신 then 블록을 배치하면 익명 함수를 가져와서 실행한다. 중첩된 코드 대신 읽기 좋은 코드가 되었다. 이런 중첩된 코드는 상호의존적인 비동기적 태스크가 많을수록 더 문제가 된다.
- catch는 오류가 발생하는 경우 실행되는 함수이다. 예를 들어 데이터베이스 연결에 실패하는 등
위의 구문은 err 객체를 가져오는 모던 자바스크립트 구문으로 인수 하나를 가져와서 뒤의 익명 함수에서 처리하는 기능이다.
======================================================================================================================================
143_제품 가져오기

models/product.js => 메서드 안의 모든 코드 삭제
    static fetchAll() {
        return db.execute('SELECT * FROM products');
    }
- SQL 키워드는 대/소문자 구분하지 않으나 핵심 SQL 키워드와 동적 값을 나타내기 위해 대문자로 입력하는 것이 관습이다.
- products에서 전부 선택하고 promise를 리턴한다. 
- then, catch를 추가할 수도 있으나 여기서 데이터를 다루려는게 아니고 fetchAll을 호출하는 장소에서 반환된 값을 다룰 것이기 때문에 여기엔 필요없다.

controllers/shop.js =>
    exports.getIndex = (req, res, next) => {
        Product.fetchAll()
        .then(([rows, fieldData]) => {
            res.render('shop/index', { 
                prods: rows,
                pageTitle: 'Shop',
                path: '/',
            });
        })
        .catch(err => { console.log(err); });
    };
- ([rows, fieldData]): then 안의 인수의 경우 중첩된 배열이 있는데 구조 분해라는 기능을 토대로 한 차세대 구문을 사용할 수 있다.
이 기능은 나의 인수 목록에 인수로서 수신하는 값의 정보를 끌어내는 기능이다.
중첩된 배열에 해당하는 result 대신 rows, fieldData로 나누는 구문을 사용한다.
fieldData는 여기에서 사용하지 않으므로 생략해도 무방하나 배열의 다양한 요소를 추출하는 방법을 알 수 있었다.

데이터베이스에 데이터 추가하기
    save() {
        return db.execute(
            'INSERT INTO products (title, price, imageUrl, description) VALUES (?, ?, ?, ?)', 
            [this.title, this.price, this.imageUrl, this.description]
        );
    }
- 정의하는 필드의 이름은 데이터베이스에 정의한 필드와 일치해야 한다. id는 데이터베이스 엔진에 의해 자동 생성되므로 생략한다.
- 사용자가 웹 페이지 입력 필드에 특이 데이터를 삽입해 SQL 쿼리로 실행할 때 발생하는 공격 패턴인 SQL Injection을 방지하기 위해 물음표를 사용한다. 데이터를 삽입하는 필드마다 물음표를 입력하고 쉼표로 나눈다.
그리고 두 번째 인자로 물음표 대신 삽입하는 값을 실행하기 위해 배열로 전달한다. 배열에 추가하는 요소는 앞선 인자의 순서와 일치해야 한다. MySQL 패키지가 입력값을 안전하게 escape해서 숨겨진 SQL 명령을 위해 파싱한 후 제거한다. 즉, 보안을 위한 절차이다.
- 최종적으로 return하여 yield를 실행하는 promise를 반환한다.

하나의 데이터만 가져오기
product =>
    static findById(id) {
        return db.execute('SELECT * FROM products WHERE products.id = ?', [id]);
    }
exports.getProduct =>
    const prodId = req.params.productId;
    Product.findById(prodId)
    .then(([product]) => {
        res.render('shop/product-detail', { 
            product: product[0],
            pageTitle: product.title,
            path: '/products'
        });
    })
    .catch(err => console.log(err));
- ([product]): 중첩 배열에서 첫 번째 요소만 가져온다.
- product: product[0] : 요소가 하나뿐이지만 배열이기 때문에 첫 번째 요소를 넘긴다.