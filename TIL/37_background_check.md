Single Thread, Event Loop & Blocking Code
Node.js가 코드를 어떻게 정확히 실행하고 계속 성능을 유지하며 파일을 다루는 등의 오래걸리는 작업을 처리하는가

기억해야 하는 것은 Node.js는 하나의 자바스크립트 스레드만 사용한다는 것이다.
스레드는 쉽게 말해 운영 체제에서의 프로세스이다.
============================================================================================
Performance 측면
보통 파일을 다루는 작업은 오래걸리는데 파일의 크기가 아주 크고, 꼭 바로 완료되는 건 아니기 때문이다.
따라서 요청으로 파일을 처리중이면 두번째 요청은 처리할 수 없기때문에 기다리거나 심지어 거부되기도 한다. 다시 말해 해당 사용자의 웹페이지가 
다운되는 것이다.
이벤트 루프는 Node.js가 시작하면 프로그램에 의해 자동으로 시작된다. 이벤트 루프는 이벤트 콜백(Event Callbacks)을 다룬다.
여태까지 createServer에 추가한 기능처럼, 특정 이벤트가 발생하면 바로 이벤트 루프가 해당 코드를 실행한다.
하지만 파일 처리처럼 오래걸리는 연산에는 도움이 되지 않는다. 그러므로 이벤트 루프는 이런 연산을 다루지 않는다. 오직 완성된 파일에 정의한 콜백에 대한
코드만 처리한다. 이런 코드는 금방 처리할 수 있다. 즉, 이벤트 루프는 빨리 끝나는 코드를 포함한 콜백만을 다룬다.

대신 파일 시스템 연산 등의 오래 걸리는 연산은 워커풀(Worker Pool)로 보낸다.(fs -> worker pool) 이 역시 Node.js가 자동으로 시작하고 관리한다.
워커풀은 말하자면 자바스크립트 코드로부터 완전히 분리되어 다른 여러 스레드에서 작동할 수 있으며 앱을 실행하는 운영체제와 깊은 연관이 있다.
코드로부터 분리되었기 때문에 무거운 작업을 모두 처리할 수 있다.
그렇지만 이벤트 루프와는 한 가지 연결점이 있다. 예를 들어 워커가 파일 읽기 작업을 마치면 읽기 파일 연산에 대한 콜백이 시작되는데 이벤트 루프가 이벤트와 콜백을 담당하기 때문에 결국 이벤트 루프에 들어가게 된다.(Trigger Callback: worker pool -> event Loop) 거기서 Node.js가 알맞은 콜백을 실행한다.

The Event Loop
Timers: Execute setTimeout, setInterval Callbacks
Node.js에 의해 실행되어 Node.js를 계속 실행하도록하는 루프로 모든 콜백을 처리한다. 콜백을 처리하는데는 일정한 순서가 있다.
새로운 반복이 시작될 때마다 실행해야 하는 타이머 콜백이 있는지 확인한다.
타이머 콜백을 등록하면 타이머가 끝난 후 실행될 콜백을 Node.js가 알고 있기 때문에 새로운 루프가 반복이 일어날 때마다 실행하게 된다. 즉, 타이머가 끝난 콜백을 실행한다.

Pending Callbacks: Execute I/O-related Callbacks that were deferrd *I/O ? Input & Output, Disk & network Operations (~Blocking Operations)
다른 콜백을 체크한다. 예를 들어 읽기 및 쓰기 파일의 연산이 끝나서 콜백이 있을 수 있는데 바로 이런 콜백을 실행한다. 일반적으로는 파일 연산이지만 네트워크 연산인 경우도 있다.
이때 Node.js는 어느 시점에 이 단계를 떠나게 되는데 만약 아직 처리되지 않은 콜백이 너무 많이 있다면 루프 반복을 이어가는 대신 남은 콜백을 다음 반복에서 실행하도록 미룬다. 이렇게 열린 콜백을 모두 처리하고 나면 다음으로 넘어간다.

Poll: Retrieve new I/O events, execute their callbacks
Node.js가 새로운 I/O 이벤트를 찾아 최대한 해당 이벤트의 콜백을 빨리 실행하도록 한다. 가능하지 않다면 뒤로 미루고 대기 콜백으로 등록한다.
또한 타이머가 끝나 실행해야 하는 콜백도 확인하는데 만약 있다면 Timers 단계로 넘어가 바로 실행하기도 한다. 즉, 반복을 이어가지 않고 다시 돌아갈 수 있다. 만약 없다면 루프가 계속 된다.

Check: Execute setImmediate() callbacks
setImmediate은 setTimeout, setInterval 처럼 바로 실행되기는 하지만 반드시 열린 콜백이 모두 실행된 다음에 실행된다.
보통 setTimeout보다 1ms만큼 빠르지만 현재 주기가 끝나거나 적어도 현 반복에 열린 콜백을 처리한 후에 일어난다.

이 이후로는 매우 이론적인 부분이다. Node.js 팀에 들어가지 않는 이상 알 필요는 없을 것
================================================================================================

Close Callbacks: Execute all 'close' event callbacks
만약 닫힌 이벤트를 등록했다면 바로 이 시점에 해당 콜백을 실행한다.

process.exit: refs == 0
프로그램 종료 단계, 그전에 등록한 이벤트 핸들러가 남지 않았는지 확실히 해야 한다. 그래서 refs가 있다. Node.js는 내부적으로 열린 이벤트 리스너를 추적해서 references나 ref로 숫자를 센다. 새 콜백이 등록되거나 새 이벤트 리스너가 등록될때마다 1씩 증가한다. 이 숫자는 이벤트 리스너가 필요없어지거나 콜백이 완료될 때마다 1씩 줄어든다. 특히 서버 환경에서 createServer로 서버를 생성하고 listen을 통해 요청을 듣는 이벤트들은 절대 끝나지 않는 이벤트기 때문에 refs는 항상 1 이상일 것이다.

정리: 먼저 타이머 콜백 -> I/O 관련 콜백 및 다른 이벤트 콜백 -> setImmediate 콜백과 닫힌 이벤트 콜백이 있다.
이때 닫힌 이벤트 콜백은 따로 처리된다. -> 프로그램 종료, 그러나 실질적으로 종료될 일은 없음