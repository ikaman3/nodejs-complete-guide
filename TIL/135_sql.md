135_소개

여태까지 프로그램에 변수와 데이터를 저장하는데 메모리를 사용했으며 요청 간에 저장된 데이터가 공유되었다. 혹은 파일에 저장하기도 했는데 데이터가 많아질수록 파일 접근이 느려지기 때문에 최적의 방법은 아니다. 그 대신 데이터 저장, 검색에 최적화된 데이터베이스를 사용한다.

- SQL과 NoSQL의 차이점에 대해 알아볼것이다.
- Node.js 앱에서 SQL을 사용하는 방법을 배울 것이다.
======================================================================================================================================
136_SQL vs NoSQL

우리의 목표는 항상 데이터를 저장하고 쉽게 가용 혹은 접근할 수 있게 하여 코드 측면뿐만 아니라 데이터 접근도 용이하게 하는 것이다. 물론 효율적이고 빨라야 한다. 이것이 데이터베이스를 사용하는 이유다. 내부 데이터가 커질수록 파일 접근보다 빠르고, 정보 한 조각을 찾기위해 전체 파일을 읽을 필요가 없다.

SQL: e.g. MySQL
- SQL DB는 테이블이라는 요소를 통해 사고하는데 즉, 사용자, 제품, 주문 테이블이 있다고 가정하자. 각각의 테이블에는 행과 열이 있다. 열은 ID, 제목, 이름 등 영역을 구성하고 레코드(행)라고 부르는 이 영역에 데이터를 채운다.
- 다른 테이블을 연결할 수 있다. 주문 테이블은 사용자와 제품 테이블의 관계로 이루어진다.
- Data Schema: 각각의 테이블마다 내부 데이터의 형태, 보유한 영역과 각각에 저장되는 데이터의 종류를 분명하게 정의한 것. 모든 데이터는 해당 테이블의 스키마와 일치해야 한다.
- Data Relations: 일대일, 일대다, 다대다 라는 세가지 중요한 상관관계를 이룬다. 즉, 테이블들이 연결되어 있다는 것이 중요한 특성이다.
- SQL Queries: 쿼리는 데이터베이스와 상호작용할 때 사용하는 언어다. SQL 언어는 몇 가지 키워드로 구성되고 이 키워드와 연결하는 몇 가지 매개변수 또는 데이터를 삽입한다. 이것이 SQL의 작동 방식이다.

NoSQL: e.g. MongoDB
- 간단히 말해 SQL의 방식을 따르지 않았다는 의미이다. 이것 또한 다양한 쿼리 언어를 사용하지만 스키마와 상관관계 대신 NoSQL은 다른 부분이나 다른 장점이 있다.
- NoSQL도 데이터베이스가 있으며 Shop 등의 이름을 지정할 수 있는데 NoSQL에서 테이블은 집합(Collection)이라고 부른다. 집합에 기록은 존재하지 않지만 문서는 존재한다. 자바스크립트의 객체와 닮은 이 문서는 JSON 포맷이다.
NoSQL에는 엄격한 스키마가 없다(Schemaless) 즉, 같은 집단에 각각 다른 구조를 지닌 다수의 문서를 저장할 수 있다. 물론 비슷한 구조로 통일하려고 하겠지만 몇몇 영역이 다른 문서도 저장할 수 있다.
- NoSQL에는 실제 상관관계가 존재하지 않는다. 대신 데이터를 복제한다. 즉, 주문 집합이 있다면 중첩된 문서인 사용자가 사용자 집합에 더 자세하게 분리된 문서로 저장된다. id, 또는 상관관계로 연결하지 않는다. 단순히 데이터를 복제하는데 정확히는 이 명령 집합에 필요한 데이터를 복제한다. 물론 데이터가 변경되면 여러 장소에서 업데이트를 해야함을 의미한다.
만약 이 장소들이 전부 최신 업데이트가 필요해도 큰 문제는 없다. 왜냐하면 데이터를 받았을 때 다수의 테이블을 하나로 합칠 필요가 없다는 이점을 제공해 매우 길고 어려운 코드가 되어 성능에 영향을 미치는 일은 없다.
- 즉, 일반적으로 NoSQL 특징은 강한 데이터 스키마가 없으며 동일한 집합에 혼합된 데이터가 존재할 수 있으며 어떤 구조도 강요되지 않고 일반적인 데이터 상관관계도 없다. 일정 부분 문서를 연관 지을 수는 있다. 
======================================================================================================================================
138_SQL, NoSQL 비교하기 

Horizontal(수평) vs Vertical Scaling(수직) Scaling(스케일링)
- 사용자가 늘어나고 데이터가 쌓여가는 앱의 유지를 위해서는 데이터베이스를 확장해야 한다. 
- 수평 스케일링은 서버를 더 추가한다. 장점은 무한으로 진행할 수 있다. 클라우드 제공업체든 자체 데이터 서버든 새로 서버를 구매하여 데이터베이스에 연결하고 서버에 데이터를 분산하면 된다. 동시에 쿼리를 모든 서버에 실행하고 지능적으로 통합하는 절차도 필요하는 것을 의미한다. 따라서 쉽지는 않지만 스케일링에 좋은 방법이다.
- 수직 스케일링은 존재하는 서버에 CPU나 메모리 등을 추가하여 더 강화하는 것을 뜻한다.
- 특히 클라우드 제공업체의 경우 이 방식이 일반적으로 용이하여 목록에서 다른 옵션을 고르고 돈을 더 내면 끝이다. 문제는 한계가 존재한다. 단일 머신에 무한정 CPU 출력을 집어넣을 수는 없다. 

SQL vs NoSQL
- SQL이 작동하는 방식으로 인해 수평 스케일링이 매우 어렵거나 심지어 불가능한 경우도 있다. 물론 서버를 추가하는 건 가능하지만 전부 하나의 공유된 데이터 클라우드, 하나의 공유된 데이터베이스에서 구동하는 건 꽤 어렵다. 수직 스케일링은 쉽게 할 수 있다.
- NoSQL은 수평 스케일링이 더 쉽다. 작동 원리를 알아야 하지만 클라우드 제공업체들이 대신해 주는 부분이다. 일반적으로 연결의 수가 적은 작동 방식으로 인해 가능한 일이다. 따라서 방대한 읽기 및 쓰기 요청에 대해 탁월한 성능을 얻게 되고 NoSQL은 처리량이 매우 많은 앱에서 고성능을 발휘한다. 물론 수직 스케일링도 가능하다.
- 여기까지만 보면 SQL이 뒤떨어지는 것처럼 보이지만 실제로는 저장하는 데이터의 종류에 따라 항상 달라진다. 상관관계가 정말 중요한 곳에 저장하고 테이블 전반에 걸쳐 분할한다던가 강력한 스키마를 보유하길 원한다면 SQL이 적합하다. 그리고 모든 데이터를 초당 몇 차례씩 액세스하지도 않는다. 데이터를 관리하는 부분이 앱에 존재할 수 있다. 따라서 자주 변경되지 않는 사용자 데이터라면 SQL이 적합하다. 
- 주문이나 장바구니 같이 앱에서 자주 변경되는 부분이라면 NoSQL이 적합하다. 이 경우 상관관계가 별로 중요하지 않는 이유는 장바구니나 주문에 해당하는 모든 정보는 단일 문서에 항상 배치할 수 있기 떄문이다. 일부 사용자 데이터를 저장한다 해도 사용자가 사진을 변경했다는 이유만으로 그 문서를 건드릴 필요는 없다. 어차피 주문과 함께 그 정보를 저장하진 않을 것이기 때문이다.
======================================================================================================================================
140_데이터베이스 연결

mysql, mysql workbench를 컴퓨터에 설치한다.
npm install --save mysql2 

sql 데이터베이스와 연결하는 방법은 두 가지가 있다. 하나는 연결 하나를 설정한 다음 쿼리를 실행하기 위해 이를 사용하는데 쿼리를 완료한 다음에는 항상 연결을 닫아야 한다. 새로운 쿼리마다 연결을 생성하기 위해 코드를 재실행해야 한다. 이것은 비효율적이다. 다른 하나는 커넥션 풀 이라는 개념이 있다.

util/database.js =>
    const mysql = require('mysql2');

    const pool = mysql.createPool({
        host: 'localhost',
        user: '사용자이름',
        database: '생성한 데이터베이스 이름',
        password: '비밀번호'
    });

    module.exports = pool.promise();
- const pool = mysql.createPool: 다중 연결을 관리하는 이 풀에서 새로운 연결을 받아오면 각 쿼리마다 개별적으로 연결이 가능하므로 다수의 쿼리를 동시에 실행할 수 있다. 쿼리가 완료되면 연결을 다시 풀로 돌려주고 새 쿼리에 사용할 수 있다. 풀은 앱을 종료할 때 완료된다.
- module.exports = pool.promise(): promise를 호출한다. 커넥션을 작업할 때 promise를 사용함으로써 콜백 대신 비동기적 태스크, 비동기적 데이터를 다룰 수 있다. 다수의 중첩 콜백 대신 promise 체인을 사용하여 더 효율적인 코딩이 가능하다.
이제 database.js 파일을 import 하여 이 풀과 커넥션에 접근할 수 있다. 

    const db = require('./util/database');
    db.execute('SELECT * FROM products');
쿼리 실행방법에는 query, execute가 있는데 후자가 좀 더 안전하므로 이걸 사용한다.